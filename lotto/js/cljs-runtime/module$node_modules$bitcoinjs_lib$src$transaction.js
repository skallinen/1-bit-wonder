shadow$provide.module$node_modules$bitcoinjs_lib$src$transaction=function(global,require,module,exports){function varSliceSize(someScript){someScript=someScript.length;return bufferutils_1.varuint.encodingLength(someScript)+someScript}function vectorSize(someVector){return bufferutils_1.varuint.encodingLength(someVector.length)+someVector.reduce((sum,witness)=>sum+varSliceSize(witness),0)}var Buffer=require("module$node_modules$buffer$index").Buffer;"use strict";Object.defineProperty(exports,"__esModule",
{value:!0});exports.Transaction=void 0;const bufferutils_1=require("module$node_modules$bitcoinjs_lib$src$bufferutils"),bcrypto=require("module$node_modules$bitcoinjs_lib$src$crypto"),bscript=require("module$node_modules$bitcoinjs_lib$src$script"),script_1=require("module$node_modules$bitcoinjs_lib$src$script"),types=require("module$node_modules$bitcoinjs_lib$src$types"),{typeforce}=types,EMPTY_BUFFER=Buffer.allocUnsafe(0),EMPTY_WITNESS=[],ZERO=Buffer.from("0000000000000000000000000000000000000000000000000000000000000000",
"hex"),ONE=Buffer.from("0000000000000000000000000000000000000000000000000000000000000001","hex");global=Buffer.from("ffffffffffffffff","hex");const BLANK_OUTPUT={script:EMPTY_BUFFER,valueBuffer:global};class Transaction{constructor(){this.version=1;this.locktime=0;this.ins=[];this.outs=[]}static fromBuffer(buffer,_NO_STRICT){const bufferReader=new bufferutils_1.BufferReader(buffer),tx=new Transaction;tx.version=bufferReader.readInt32();var marker=bufferReader.readUInt8(),flag=bufferReader.readUInt8(),
hasWitnesses=!1;marker===Transaction.ADVANCED_TRANSACTION_MARKER&&flag===Transaction.ADVANCED_TRANSACTION_FLAG?hasWitnesses=!0:bufferReader.offset-=2;marker=bufferReader.readVarInt();for(flag=0;flag<marker;++flag)tx.ins.push({hash:bufferReader.readSlice(32),index:bufferReader.readUInt32(),script:bufferReader.readVarSlice(),sequence:bufferReader.readUInt32(),witness:EMPTY_WITNESS});flag=bufferReader.readVarInt();for(let i=0;i<flag;++i)tx.outs.push({value:bufferReader.readUInt64(),script:bufferReader.readVarSlice()});
if(hasWitnesses){for(hasWitnesses=0;hasWitnesses<marker;++hasWitnesses)tx.ins[hasWitnesses].witness=bufferReader.readVector();if(!tx.hasWitnesses())throw Error("Transaction has superfluous witness data");}tx.locktime=bufferReader.readUInt32();if(_NO_STRICT)return tx;if(bufferReader.offset!==buffer.length)throw Error("Transaction has unexpected data");return tx}static fromHex(hex){return Transaction.fromBuffer(Buffer.from(hex,"hex"),!1)}static isCoinbaseHash(buffer){typeforce(types.Hash256bit,buffer);
for(let i=0;32>i;++i)if(0!==buffer[i])return!1;return!0}isCoinbase(){return 1===this.ins.length&&Transaction.isCoinbaseHash(this.ins[0].hash)}addInput(hash,index,sequence,scriptSig){typeforce(types.tuple(types.Hash256bit,types.UInt32,types.maybe(types.UInt32),types.maybe(types.Buffer)),arguments);types.Null(sequence)&&(sequence=Transaction.DEFAULT_SEQUENCE);return this.ins.push({hash,index,script:scriptSig||EMPTY_BUFFER,sequence,witness:EMPTY_WITNESS})-1}addOutput(scriptPubKey,value){typeforce(types.tuple(types.Buffer,
types.Satoshi),arguments);return this.outs.push({script:scriptPubKey,value})-1}hasWitnesses(){return this.ins.some(x=>0!==x.witness.length)}weight(){const base=this.byteLength(!1),total=this.byteLength(!0);return 3*base+total}virtualSize(){return Math.ceil(this.weight()/4)}byteLength(_ALLOW_WITNESS=!0){_ALLOW_WITNESS=_ALLOW_WITNESS&&this.hasWitnesses();return(_ALLOW_WITNESS?10:8)+bufferutils_1.varuint.encodingLength(this.ins.length)+bufferutils_1.varuint.encodingLength(this.outs.length)+this.ins.reduce((sum,
input)=>sum+40+varSliceSize(input.script),0)+this.outs.reduce((sum,output)=>sum+8+varSliceSize(output.script),0)+(_ALLOW_WITNESS?this.ins.reduce((sum,input)=>sum+vectorSize(input.witness),0):0)}clone(){const newTx=new Transaction;newTx.version=this.version;newTx.locktime=this.locktime;newTx.ins=this.ins.map(txIn=>({hash:txIn.hash,index:txIn.index,script:txIn.script,sequence:txIn.sequence,witness:txIn.witness}));newTx.outs=this.outs.map(txOut=>({script:txOut.script,value:txOut.value}));return newTx}hashForSignature(inIndex,
prevOutScript,hashType){typeforce(types.tuple(types.UInt32,types.Buffer,types.Number),arguments);if(inIndex>=this.ins.length)return ONE;var ourScript=bscript.compile(bscript.decompile(prevOutScript).filter(x=>x!==script_1.OPS.OP_CODESEPARATOR));const txTmp=this.clone();if((hashType&31)===Transaction.SIGHASH_NONE)txTmp.outs=[],txTmp.ins.forEach((input,i)=>{i!==inIndex&&(input.sequence=0)});else if((hashType&31)===Transaction.SIGHASH_SINGLE){if(inIndex>=this.outs.length)return ONE;txTmp.outs.length=
inIndex+1;for(let i=0;i<inIndex;i++)txTmp.outs[i]=BLANK_OUTPUT;txTmp.ins.forEach((input,y)=>{y!==inIndex&&(input.sequence=0)})}hashType&Transaction.SIGHASH_ANYONECANPAY?(txTmp.ins=[txTmp.ins[inIndex]],txTmp.ins[0].script=ourScript):(txTmp.ins.forEach(input=>{input.script=EMPTY_BUFFER}),txTmp.ins[inIndex].script=ourScript);ourScript=Buffer.allocUnsafe(txTmp.byteLength(!1)+4);ourScript.writeInt32LE(hashType,ourScript.length-4);txTmp.__toBuffer(ourScript,0,!1);return bcrypto.hash256(ourScript)}hashForWitnessV1(inIndex,
prevOutScripts,values,hashType,leafHash,annex){typeforce(types.tuple(types.UInt32,typeforce.arrayOf(types.Buffer),typeforce.arrayOf(types.Satoshi),types.UInt32),arguments);if(values.length!==this.ins.length||prevOutScripts.length!==this.ins.length)throw Error("Must supply prevout script and value for all inputs");var outputType=hashType===Transaction.SIGHASH_DEFAULT?Transaction.SIGHASH_ALL:hashType&Transaction.SIGHASH_OUTPUT_MASK,isAnyoneCanPay=(hashType&Transaction.SIGHASH_INPUT_MASK)===Transaction.SIGHASH_ANYONECANPAY;
const isNone=outputType===Transaction.SIGHASH_NONE;outputType=outputType===Transaction.SIGHASH_SINGLE;let hashPrevouts=EMPTY_BUFFER,hashAmounts=EMPTY_BUFFER,hashScriptPubKeys=EMPTY_BUFFER,hashSequences=EMPTY_BUFFER;var hashOutputs=EMPTY_BUFFER;if(!isAnyoneCanPay){let bufferWriter=bufferutils_1.BufferWriter.withCapacity(36*this.ins.length);this.ins.forEach(txIn=>{bufferWriter.writeSlice(txIn.hash);bufferWriter.writeUInt32(txIn.index)});hashPrevouts=bcrypto.sha256(bufferWriter.end());bufferWriter=bufferutils_1.BufferWriter.withCapacity(8*
this.ins.length);values.forEach(value=>bufferWriter.writeUInt64(value));hashAmounts=bcrypto.sha256(bufferWriter.end());bufferWriter=bufferutils_1.BufferWriter.withCapacity(prevOutScripts.map(varSliceSize).reduce((a,b)=>a+b));prevOutScripts.forEach(prevOutScript=>bufferWriter.writeVarSlice(prevOutScript));hashScriptPubKeys=bcrypto.sha256(bufferWriter.end());bufferWriter=bufferutils_1.BufferWriter.withCapacity(4*this.ins.length);this.ins.forEach(txIn=>bufferWriter.writeUInt32(txIn.sequence));hashSequences=
bcrypto.sha256(bufferWriter.end())}if(!isNone&&!outputType){hashOutputs=this.outs.map(output=>8+varSliceSize(output.script)).reduce((a,b)=>a+b);const bufferWriter=bufferutils_1.BufferWriter.withCapacity(hashOutputs);this.outs.forEach(out=>{bufferWriter.writeUInt64(out.value);bufferWriter.writeVarSlice(out.script)});hashOutputs=bcrypto.sha256(bufferWriter.end())}else if(outputType&&inIndex<this.outs.length){hashOutputs=this.outs[inIndex];var bufferWriter$jscomp$0=bufferutils_1.BufferWriter.withCapacity(8+
varSliceSize(hashOutputs.script));bufferWriter$jscomp$0.writeUInt64(hashOutputs.value);bufferWriter$jscomp$0.writeVarSlice(hashOutputs.script);hashOutputs=bcrypto.sha256(bufferWriter$jscomp$0.end())}const spendType=(leafHash?2:0)+(annex?1:0);bufferWriter$jscomp$0=bufferutils_1.BufferWriter.withCapacity(174-(isAnyoneCanPay?49:0)-(isNone?32:0)+(annex?32:0)+(leafHash?37:0));bufferWriter$jscomp$0.writeUInt8(hashType);bufferWriter$jscomp$0.writeInt32(this.version);bufferWriter$jscomp$0.writeUInt32(this.locktime);
bufferWriter$jscomp$0.writeSlice(hashPrevouts);bufferWriter$jscomp$0.writeSlice(hashAmounts);bufferWriter$jscomp$0.writeSlice(hashScriptPubKeys);bufferWriter$jscomp$0.writeSlice(hashSequences);isNone||outputType||bufferWriter$jscomp$0.writeSlice(hashOutputs);bufferWriter$jscomp$0.writeUInt8(spendType);isAnyoneCanPay?(isAnyoneCanPay=this.ins[inIndex],bufferWriter$jscomp$0.writeSlice(isAnyoneCanPay.hash),bufferWriter$jscomp$0.writeUInt32(isAnyoneCanPay.index),bufferWriter$jscomp$0.writeUInt64(values[inIndex]),
bufferWriter$jscomp$0.writeVarSlice(prevOutScripts[inIndex]),bufferWriter$jscomp$0.writeUInt32(isAnyoneCanPay.sequence)):bufferWriter$jscomp$0.writeUInt32(inIndex);annex&&(isAnyoneCanPay=bufferutils_1.BufferWriter.withCapacity(varSliceSize(annex)),isAnyoneCanPay.writeVarSlice(annex),bufferWriter$jscomp$0.writeSlice(bcrypto.sha256(isAnyoneCanPay.end())));outputType&&bufferWriter$jscomp$0.writeSlice(hashOutputs);leafHash&&(bufferWriter$jscomp$0.writeSlice(leafHash),bufferWriter$jscomp$0.writeUInt8(0),
bufferWriter$jscomp$0.writeUInt32(4294967295));return bcrypto.taggedHash("TapSighash",Buffer.concat([Buffer.of(0),bufferWriter$jscomp$0.end()]))}hashForWitnessV0(inIndex,prevOutScript,value,hashType){typeforce(types.tuple(types.UInt32,types.Buffer,types.Satoshi,types.UInt32),arguments);var tbuffer=Buffer.from([]);let bufferWriter;var hashOutputs=ZERO;let hashPrevouts=ZERO,hashSequence=ZERO;hashType&Transaction.SIGHASH_ANYONECANPAY||(tbuffer=Buffer.allocUnsafe(36*this.ins.length),bufferWriter=new bufferutils_1.BufferWriter(tbuffer,
0),this.ins.forEach(txIn=>{bufferWriter.writeSlice(txIn.hash);bufferWriter.writeUInt32(txIn.index)}),hashPrevouts=bcrypto.hash256(tbuffer));hashType&Transaction.SIGHASH_ANYONECANPAY||(hashType&31)===Transaction.SIGHASH_SINGLE||(hashType&31)===Transaction.SIGHASH_NONE||(tbuffer=Buffer.allocUnsafe(4*this.ins.length),bufferWriter=new bufferutils_1.BufferWriter(tbuffer,0),this.ins.forEach(txIn=>{bufferWriter.writeUInt32(txIn.sequence)}),hashSequence=bcrypto.hash256(tbuffer));(hashType&31)!==Transaction.SIGHASH_SINGLE&&
(hashType&31)!==Transaction.SIGHASH_NONE?(tbuffer=this.outs.reduce((sum,output)=>sum+8+varSliceSize(output.script),0),tbuffer=Buffer.allocUnsafe(tbuffer),bufferWriter=new bufferutils_1.BufferWriter(tbuffer,0),this.outs.forEach(out=>{bufferWriter.writeUInt64(out.value);bufferWriter.writeVarSlice(out.script)}),hashOutputs=bcrypto.hash256(tbuffer)):(hashType&31)===Transaction.SIGHASH_SINGLE&&inIndex<this.outs.length&&(hashOutputs=this.outs[inIndex],tbuffer=Buffer.allocUnsafe(8+varSliceSize(hashOutputs.script)),
bufferWriter=new bufferutils_1.BufferWriter(tbuffer,0),bufferWriter.writeUInt64(hashOutputs.value),bufferWriter.writeVarSlice(hashOutputs.script),hashOutputs=bcrypto.hash256(tbuffer));tbuffer=Buffer.allocUnsafe(156+varSliceSize(prevOutScript));bufferWriter=new bufferutils_1.BufferWriter(tbuffer,0);const input=this.ins[inIndex];bufferWriter.writeInt32(this.version);bufferWriter.writeSlice(hashPrevouts);bufferWriter.writeSlice(hashSequence);bufferWriter.writeSlice(input.hash);bufferWriter.writeUInt32(input.index);
bufferWriter.writeVarSlice(prevOutScript);bufferWriter.writeUInt64(value);bufferWriter.writeUInt32(input.sequence);bufferWriter.writeSlice(hashOutputs);bufferWriter.writeUInt32(this.locktime);bufferWriter.writeUInt32(hashType);return bcrypto.hash256(tbuffer)}getHash(forWitness){return forWitness&&this.isCoinbase()?Buffer.alloc(32,0):bcrypto.hash256(this.__toBuffer(void 0,void 0,forWitness))}getId(){return(0,bufferutils_1.reverseBuffer)(this.getHash(!1)).toString("hex")}toBuffer(buffer,initialOffset){return this.__toBuffer(buffer,
initialOffset,!0)}toHex(){return this.toBuffer(void 0,void 0).toString("hex")}setInputScript(index,scriptSig){typeforce(types.tuple(types.Number,types.Buffer),arguments);this.ins[index].script=scriptSig}setWitness(index,witness){typeforce(types.tuple(types.Number,[types.Buffer]),arguments);this.ins[index].witness=witness}__toBuffer(buffer,initialOffset,_ALLOW_WITNESS=!1){buffer||(buffer=Buffer.allocUnsafe(this.byteLength(_ALLOW_WITNESS)));const bufferWriter=new bufferutils_1.BufferWriter(buffer,initialOffset||
0);bufferWriter.writeInt32(this.version);if(_ALLOW_WITNESS=_ALLOW_WITNESS&&this.hasWitnesses())bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER),bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG);bufferWriter.writeVarInt(this.ins.length);this.ins.forEach(txIn=>{bufferWriter.writeSlice(txIn.hash);bufferWriter.writeUInt32(txIn.index);bufferWriter.writeVarSlice(txIn.script);bufferWriter.writeUInt32(txIn.sequence)});bufferWriter.writeVarInt(this.outs.length);this.outs.forEach(txOut=>
{void 0!==txOut.value?bufferWriter.writeUInt64(txOut.value):bufferWriter.writeSlice(txOut.valueBuffer);bufferWriter.writeVarSlice(txOut.script)});_ALLOW_WITNESS&&this.ins.forEach(input=>{bufferWriter.writeVector(input.witness)});bufferWriter.writeUInt32(this.locktime);return void 0!==initialOffset?buffer.slice(initialOffset,bufferWriter.offset):buffer}}exports.Transaction=Transaction;Transaction.DEFAULT_SEQUENCE=4294967295;Transaction.SIGHASH_DEFAULT=0;Transaction.SIGHASH_ALL=1;Transaction.SIGHASH_NONE=
2;Transaction.SIGHASH_SINGLE=3;Transaction.SIGHASH_ANYONECANPAY=128;Transaction.SIGHASH_OUTPUT_MASK=3;Transaction.SIGHASH_INPUT_MASK=128;Transaction.ADVANCED_TRANSACTION_MARKER=0;Transaction.ADVANCED_TRANSACTION_FLAG=1}
//# sourceMappingURL=module$node_modules$bitcoinjs_lib$src$transaction.js.map
