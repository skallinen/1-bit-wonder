shadow$provide.module$node_modules$bitcoinjs_lib$src$payments$embed=function(global,require,module,exports){function stacksEqual(a,b){return a.length!==b.length?!1:a.every((x,i)=>x.equals(b[i]))}Object.defineProperty(exports,"__esModule",{value:!0});exports.p2data=void 0;const networks_1=require("module$node_modules$bitcoinjs_lib$src$networks"),bscript=require("module$node_modules$bitcoinjs_lib$src$script"),types_1=require("module$node_modules$bitcoinjs_lib$src$types"),lazy=require("module$node_modules$bitcoinjs_lib$src$payments$lazy"),
OPS=bscript.OPS;exports.p2data=function(a,opts){if(!a.data&&!a.output)throw new TypeError("Not enough data");opts=Object.assign({validate:!0},opts||{});(0,types_1.typeforce)({network:types_1.typeforce.maybe(types_1.typeforce.Object),output:types_1.typeforce.maybe(types_1.typeforce.Buffer),data:types_1.typeforce.maybe(types_1.typeforce.arrayOf(types_1.typeforce.Buffer))},a);const o={name:"embed",network:a.network||networks_1.bitcoin};lazy.prop(o,"output",()=>{if(a.data)return bscript.compile([OPS.OP_RETURN].concat(a.data))});
lazy.prop(o,"data",()=>{if(a.output)return bscript.decompile(a.output).slice(1)});if(opts.validate&&a.output){opts=bscript.decompile(a.output);if(opts[0]!==OPS.OP_RETURN)throw new TypeError("Output is invalid");if(!opts.slice(1).every(types_1.typeforce.Buffer))throw new TypeError("Output is invalid");if(a.data&&!stacksEqual(a.data,o.data))throw new TypeError("Data mismatch");}return Object.assign(o,a)}}
//# sourceMappingURL=module$node_modules$bitcoinjs_lib$src$payments$embed.js.map
