shadow$provide.module$node_modules$bitcoinjs_lib$src$script=function(global,require,module,exports){function isPushOnlyChunk(value){var JSCompiler_temp;(JSCompiler_temp=types.Buffer(value))||(JSCompiler_temp=types.Number(value)&&(value===ops_1.OPS.OP_0||value>=ops_1.OPS.OP_1&&value<=ops_1.OPS.OP_16||value===ops_1.OPS.OP_1NEGATE));return JSCompiler_temp}function isPushOnly(value){return types.Array(value)&&value.every(isPushOnlyChunk)}function asMinimalOP(buffer){if(0===buffer.length)return ops_1.OPS.OP_0;
if(1===buffer.length){if(1<=buffer[0]&&16>=buffer[0])return OP_INT_BASE+buffer[0];if(129===buffer[0])return ops_1.OPS.OP_1NEGATE}}function compile(chunks){if(Buffer.isBuffer(chunks))return chunks;typeforce(types.Array,chunks);const bufferSize=chunks.reduce((accum,chunk)=>Buffer.isBuffer(chunk)?1===chunk.length&&void 0!==asMinimalOP(chunk)?accum+1:accum+pushdata.encodingLength(chunk.length)+chunk.length:accum+1,0),buffer=Buffer.allocUnsafe(bufferSize);let offset=0;chunks.forEach(chunk=>{if(Buffer.isBuffer(chunk)){const opcode=
asMinimalOP(chunk);void 0!==opcode?(buffer.writeUInt8(opcode,offset),offset+=1):(offset+=pushdata.encode(buffer,chunk.length,offset),chunk.copy(buffer,offset),offset+=chunk.length)}else buffer.writeUInt8(chunk,offset),offset+=1});if(offset!==buffer.length)throw Error("Could not decode chunks");return buffer}function decompile(buffer){if(types.Array(buffer))return buffer;typeforce(types.Buffer,buffer);const chunks=[];let i=0;for(;i<buffer.length;){var opcode=buffer[i];if(opcode>ops_1.OPS.OP_0&&opcode<=
ops_1.OPS.OP_PUSHDATA4){var d=pushdata.decode(buffer,i);if(null===d)return null;i+=d.size;if(i+d.number>buffer.length)return null;opcode=buffer.slice(i,i+d.number);i+=d.number;d=asMinimalOP(opcode);void 0!==d?chunks.push(d):chunks.push(opcode)}else chunks.push(opcode),i+=1}return chunks}function isDefinedHashType(hashType){hashType&=-129;return 0<hashType&&4>hashType}var Buffer=require("module$node_modules$buffer$index").Buffer;"use strict";Object.defineProperty(exports,"__esModule",{value:!0});exports.signature=
exports.number=exports.isCanonicalScriptSignature=exports.isDefinedHashType=exports.isCanonicalPubKey=exports.toStack=exports.fromASM=exports.toASM=exports.decompile=exports.compile=exports.isPushOnly=exports.OPS=void 0;const bip66=require("module$node_modules$bitcoinjs_lib$src$bip66"),ops_1=require("module$node_modules$bitcoinjs_lib$src$ops");Object.defineProperty(exports,"OPS",{enumerable:!0,get:function(){return ops_1.OPS}});const pushdata=require("module$node_modules$bitcoinjs_lib$src$push_data"),
scriptNumber=require("module$node_modules$bitcoinjs_lib$src$script_number");global=require("module$node_modules$bitcoinjs_lib$src$script_signature");const types=require("module$node_modules$bitcoinjs_lib$src$types"),{typeforce}=types,OP_INT_BASE=ops_1.OPS.OP_RESERVED;exports.isPushOnly=isPushOnly;exports.compile=compile;exports.decompile=decompile;exports.toASM=function(chunks){Buffer.isBuffer(chunks)&&(chunks=decompile(chunks));return chunks.map(chunk=>{if(Buffer.isBuffer(chunk)){const op=asMinimalOP(chunk);
if(void 0===op)return chunk.toString("hex");chunk=op}return ops_1.REVERSE_OPS[chunk]}).join(" ")};exports.fromASM=function(asm){typeforce(types.String,asm);return compile(asm.split(" ").map(chunkStr=>{if(void 0!==ops_1.OPS[chunkStr])return ops_1.OPS[chunkStr];typeforce(types.Hex,chunkStr);return Buffer.from(chunkStr,"hex")}))};exports.toStack=function(chunks){chunks=decompile(chunks);typeforce(isPushOnly,chunks);return chunks.map(op=>Buffer.isBuffer(op)?op:op===ops_1.OPS.OP_0?Buffer.allocUnsafe(0):
scriptNumber.encode(op-OP_INT_BASE))};exports.isCanonicalPubKey=function(buffer){return types.isPoint(buffer)};exports.isDefinedHashType=isDefinedHashType;exports.isCanonicalScriptSignature=function(buffer){return Buffer.isBuffer(buffer)&&isDefinedHashType(buffer[buffer.length-1])?bip66.check(buffer.slice(0,-1)):!1};exports.number=scriptNumber;exports.signature=global}
//# sourceMappingURL=module$node_modules$bitcoinjs_lib$src$script.js.map
