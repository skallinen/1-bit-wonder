shadow$provide.module$node_modules$tiny_secp256k1$js=function(global,require,module,exports){function isScalar(x){return Buffer.isBuffer(x)&&32===x.length}function isOrderScalar(x){return isScalar(x)?0>x.compare(EC_GROUP_ORDER):!1}function isPoint(p){if(!Buffer.isBuffer(p)||33>p.length)return!1;const t=p[0];var x=p.slice(1,33);if(0===x.compare(ZERO32)||0<=x.compare(EC_P))return!1;if((2===t||3===t)&&33===p.length){try{decodeFrom(p)}catch(e){return!1}return!0}x=p.slice(33);return 0===x.compare(ZERO32)||
0<=x.compare(EC_P)?!1:4===t&&65===p.length?!0:!1}function isPrivate(x){return isScalar(x)?0<x.compare(ZERO32)&&0>x.compare(EC_GROUP_ORDER):!1}function assumeCompression(value,pubkey){return void 0===value&&void 0!==pubkey?4!==pubkey[0]:void 0===value?!0:value}function fromBuffer(d){return new BN(d)}function decodeFrom(P){return secp256k1.curve.decodePoint(P)}function __sign(hash,x,addData){if(!isScalar(hash))throw new TypeError("Expected Hash");if(!isPrivate(x))throw new TypeError("Expected Private");
if(void 0!==addData&&!isScalar(addData))throw new TypeError("Expected Extra Data (32 bytes)");const d=fromBuffer(x),e=fromBuffer(hash);let r,s;deterministicGenerateK(hash,x,function(k){k=fromBuffer(k);const Q=G.mul(k);if(Q.isInfinity())return!1;r=Q.x.umod(n);if(0===r.isZero())return!1;s=k.invm(n).mul(e.add(d.mul(r))).umod(n);return 0===s.isZero()?!1:!0},isPrivate,addData);0<s.cmp(nDiv2)&&(s=n.sub(s));hash=Buffer.allocUnsafe(64);r.toArrayLike(Buffer,"be",32).copy(hash,0);s.toArrayLike(Buffer,"be",
32).copy(hash,32);return hash}var Buffer=require("module$node_modules$buffer$index").Buffer;const BN=require("module$node_modules$tiny_secp256k1$node_modules$bn_js$lib$bn"),secp256k1=new (require("module$node_modules$elliptic$lib$elliptic").ec)("secp256k1"),deterministicGenerateK=require("module$node_modules$tiny_secp256k1$rfc6979"),ZERO32=Buffer.alloc(32,0),EC_GROUP_ORDER=Buffer.from("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141","hex"),EC_P=Buffer.from("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f",
"hex"),n=secp256k1.curve.n,nDiv2=n.shrn(1),G=secp256k1.curve.g;module.exports={isPoint,isPointCompressed:function(p){return isPoint(p)?4!==p[0]:!1},isPrivate,pointAdd:function(pA,pB,__compressed){if(!isPoint(pA))throw new TypeError("Expected Point");if(!isPoint(pB))throw new TypeError("Expected Point");var a=decodeFrom(pA);pB=decodeFrom(pB);a=a.add(pB);if(a.isInfinity())return null;pA=assumeCompression(__compressed,pA);return Buffer.from(a._encode(pA))},pointAddScalar:function(p,tweak,__compressed){if(!isPoint(p))throw new TypeError("Expected Point");
if(!isOrderScalar(tweak))throw new TypeError("Expected Tweak");__compressed=assumeCompression(__compressed,p);p=decodeFrom(p);if(0===tweak.compare(ZERO32))return Buffer.from(p._encode(__compressed));tweak=fromBuffer(tweak);tweak=G.mul(tweak);tweak=p.add(tweak);return tweak.isInfinity()?null:Buffer.from(tweak._encode(__compressed))},pointCompress:function(p,__compressed){if(!isPoint(p))throw new TypeError("Expected Point");const pp=decodeFrom(p);if(pp.isInfinity())throw new TypeError("Expected Point");
p=assumeCompression(__compressed,p);return Buffer.from(pp._encode(p))},pointFromScalar:function(d,__compressed){if(!isPrivate(d))throw new TypeError("Expected Private");d=fromBuffer(d);d=G.mul(d);if(d.isInfinity())return null;__compressed=assumeCompression(__compressed);return Buffer.from(d._encode(__compressed))},pointMultiply:function(p,tweak,__compressed){if(!isPoint(p))throw new TypeError("Expected Point");if(!isOrderScalar(tweak))throw new TypeError("Expected Tweak");__compressed=assumeCompression(__compressed,
p);p=decodeFrom(p);tweak=fromBuffer(tweak);tweak=p.mul(tweak);return tweak.isInfinity()?null:Buffer.from(tweak._encode(__compressed))},privateAdd:function(d,tweak){if(!isPrivate(d))throw new TypeError("Expected Private");if(!isOrderScalar(tweak))throw new TypeError("Expected Tweak");d=fromBuffer(d);tweak=fromBuffer(tweak);tweak=d.add(tweak).umod(n).toArrayLike(Buffer,"be",32);return isPrivate(tweak)?tweak:null},privateSub:function(d,tweak){if(!isPrivate(d))throw new TypeError("Expected Private");
if(!isOrderScalar(tweak))throw new TypeError("Expected Tweak");d=fromBuffer(d);tweak=fromBuffer(tweak);tweak=d.sub(tweak).umod(n).toArrayLike(Buffer,"be",32);return isPrivate(tweak)?tweak:null},sign:function(hash,x){return __sign(hash,x)},signWithEntropy:function(hash,x,addData){return __sign(hash,x,addData)},verify:function(hash,q,signature,strict){if(!isScalar(hash))throw new TypeError("Expected Hash");if(!isPoint(q))throw new TypeError("Expected Point");var r=signature.slice(0,32);const s=signature.slice(32,
64);if(!(Buffer.isBuffer(signature)&&64===signature.length&&0>r.compare(EC_GROUP_ORDER)&&0>s.compare(EC_GROUP_ORDER)))throw new TypeError("Expected Signature");r=decodeFrom(q);q=fromBuffer(signature.slice(0,32));signature=fromBuffer(signature.slice(32,64));if(strict&&0<signature.cmp(nDiv2)||0>=q.gtn(0)||0>=signature.gtn(0))return!1;hash=fromBuffer(hash);strict=signature.invm(n);hash=hash.mul(strict).umod(n);strict=q.mul(strict).umod(n);r=G.mulAdd(hash,r,strict);return r.isInfinity()?!1:r.x.umod(n).eq(q)}}}
//# sourceMappingURL=module$node_modules$tiny_secp256k1$js.js.map
