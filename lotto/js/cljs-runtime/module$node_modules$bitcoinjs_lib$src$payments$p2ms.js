shadow$provide.module$node_modules$bitcoinjs_lib$src$payments$p2ms=function(global,require,module,exports){function stacksEqual(a,b){return a.length!==b.length?!1:a.every((x,i)=>x.equals(b[i]))}Object.defineProperty(exports,"__esModule",{value:!0});exports.p2ms=void 0;const networks_1=require("module$node_modules$bitcoinjs_lib$src$networks"),bscript=require("module$node_modules$bitcoinjs_lib$src$script"),types_1=require("module$node_modules$bitcoinjs_lib$src$types"),lazy=require("module$node_modules$bitcoinjs_lib$src$payments$lazy"),
OPS=bscript.OPS,OP_INT_BASE=OPS.OP_RESERVED;exports.p2ms=function(a,opts){function isAcceptableSignature(x){return bscript.isCanonicalScriptSignature(x)||void 0!==(opts.allowIncomplete&&x===OPS.OP_0)}function decode(output){decoded||(decoded=!0,chunks=bscript.decompile(output),o.m=chunks[0]-OP_INT_BASE,o.n=chunks[chunks.length-2]-OP_INT_BASE,o.pubkeys=chunks.slice(1,-2))}if(!(a.input||a.output||a.pubkeys&&void 0!==a.m||a.signatures))throw new TypeError("Not enough data");opts=Object.assign({validate:!0},
opts||{});(0,types_1.typeforce)({network:types_1.typeforce.maybe(types_1.typeforce.Object),m:types_1.typeforce.maybe(types_1.typeforce.Number),n:types_1.typeforce.maybe(types_1.typeforce.Number),output:types_1.typeforce.maybe(types_1.typeforce.Buffer),pubkeys:types_1.typeforce.maybe(types_1.typeforce.arrayOf(types_1.isPoint)),signatures:types_1.typeforce.maybe(types_1.typeforce.arrayOf(isAcceptableSignature)),input:types_1.typeforce.maybe(types_1.typeforce.Buffer)},a);const o={network:a.network||
networks_1.bitcoin};let chunks=[],decoded=!1;lazy.prop(o,"output",()=>{if(a.m&&o.n&&a.pubkeys)return bscript.compile([].concat(OP_INT_BASE+a.m,a.pubkeys,OP_INT_BASE+o.n,OPS.OP_CHECKMULTISIG))});lazy.prop(o,"m",()=>{if(o.output)return decode(o.output),o.m});lazy.prop(o,"n",()=>{if(o.pubkeys)return o.pubkeys.length});lazy.prop(o,"pubkeys",()=>{if(a.output)return decode(a.output),o.pubkeys});lazy.prop(o,"signatures",()=>{if(a.input)return bscript.decompile(a.input).slice(1)});lazy.prop(o,"input",()=>
{if(a.signatures)return bscript.compile([OPS.OP_0].concat(a.signatures))});lazy.prop(o,"witness",()=>{if(o.input)return[]});lazy.prop(o,"name",()=>{if(o.m&&o.n)return`p2ms(${o.m} of ${o.n})`});if(opts.validate){if(a.output){decode(a.output);if(!types_1.typeforce.Number(chunks[0]))throw new TypeError("Output is invalid");if(!types_1.typeforce.Number(chunks[chunks.length-2]))throw new TypeError("Output is invalid");if(chunks[chunks.length-1]!==OPS.OP_CHECKMULTISIG)throw new TypeError("Output is invalid");
if(0>=o.m||16<o.n||o.m>o.n||o.n!==chunks.length-3)throw new TypeError("Output is invalid");if(!o.pubkeys.every(x=>(0,types_1.isPoint)(x)))throw new TypeError("Output is invalid");if(void 0!==a.m&&a.m!==o.m)throw new TypeError("m mismatch");if(void 0!==a.n&&a.n!==o.n)throw new TypeError("n mismatch");if(a.pubkeys&&!stacksEqual(a.pubkeys,o.pubkeys))throw new TypeError("Pubkeys mismatch");}if(a.pubkeys){if(void 0!==a.n&&a.n!==a.pubkeys.length)throw new TypeError("Pubkey count mismatch");o.n=a.pubkeys.length;
if(o.n<o.m)throw new TypeError("Pubkey count cannot be less than m");}if(a.signatures){if(a.signatures.length<o.m)throw new TypeError("Not enough signatures provided");if(a.signatures.length>o.m)throw new TypeError("Too many signatures provided");}if(a.input){if(a.input[0]!==OPS.OP_0)throw new TypeError("Input is invalid");if(0===o.signatures.length||!o.signatures.every(isAcceptableSignature))throw new TypeError("Input has invalid signature(s)");if(a.signatures&&!stacksEqual(a.signatures,o.signatures))throw new TypeError("Signature mismatch");
if(void 0!==a.m&&a.m!==a.signatures.length)throw new TypeError("Signature count mismatch");}}return Object.assign(o,a)}}
//# sourceMappingURL=module$node_modules$bitcoinjs_lib$src$payments$p2ms.js.map
