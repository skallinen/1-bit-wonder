shadow$provide.module$node_modules$bip174$src$lib$parser$fromBuffer=function(global,require,module,exports){function checkKeyBuffer(type,keyBuf,keyNum){if(!keyBuf.equals(Buffer.from([keyNum])))throw Error(`Format Error: Invalid ${type} key: ${keyBuf.toString("hex")}`);}function psbtFromKeyVals(unsignedTx,{globalMapKeyVals,inputKeyVals,outputKeyVals}){unsignedTx={unsignedTx};var txCount=0;for(var keyVal$jscomp$0 of globalMapKeyVals)switch(keyVal$jscomp$0.key[0]){case typeFields_1.GlobalTypes.UNSIGNED_TX:checkKeyBuffer("global",
keyVal$jscomp$0.key,typeFields_1.GlobalTypes.UNSIGNED_TX);if(0<txCount)throw Error("Format Error: GlobalMap has multiple UNSIGNED_TX");txCount++;break;case typeFields_1.GlobalTypes.GLOBAL_XPUB:void 0===unsignedTx.globalXpub&&(unsignedTx.globalXpub=[]);unsignedTx.globalXpub.push(convert.globals.globalXpub.decode(keyVal$jscomp$0));break;default:unsignedTx.unknownKeyVals||(unsignedTx.unknownKeyVals=[]),unsignedTx.unknownKeyVals.push(keyVal$jscomp$0)}var inputCount=inputKeyVals.length;txCount=outputKeyVals.length;
globalMapKeyVals=[];keyVal$jscomp$0=[];for(const index of tools_1.range(inputCount)){inputCount={};for(const keyVal of inputKeyVals[index])switch(convert.inputs.checkPubkey(keyVal),keyVal.key[0]){case typeFields_1.InputTypes.NON_WITNESS_UTXO:checkKeyBuffer("input",keyVal.key,typeFields_1.InputTypes.NON_WITNESS_UTXO);if(void 0!==inputCount.nonWitnessUtxo)throw Error("Format Error: Input has multiple NON_WITNESS_UTXO");inputCount.nonWitnessUtxo=convert.inputs.nonWitnessUtxo.decode(keyVal);break;case typeFields_1.InputTypes.WITNESS_UTXO:checkKeyBuffer("input",
keyVal.key,typeFields_1.InputTypes.WITNESS_UTXO);if(void 0!==inputCount.witnessUtxo)throw Error("Format Error: Input has multiple WITNESS_UTXO");inputCount.witnessUtxo=convert.inputs.witnessUtxo.decode(keyVal);break;case typeFields_1.InputTypes.PARTIAL_SIG:void 0===inputCount.partialSig&&(inputCount.partialSig=[]);inputCount.partialSig.push(convert.inputs.partialSig.decode(keyVal));break;case typeFields_1.InputTypes.SIGHASH_TYPE:checkKeyBuffer("input",keyVal.key,typeFields_1.InputTypes.SIGHASH_TYPE);
if(void 0!==inputCount.sighashType)throw Error("Format Error: Input has multiple SIGHASH_TYPE");inputCount.sighashType=convert.inputs.sighashType.decode(keyVal);break;case typeFields_1.InputTypes.REDEEM_SCRIPT:checkKeyBuffer("input",keyVal.key,typeFields_1.InputTypes.REDEEM_SCRIPT);if(void 0!==inputCount.redeemScript)throw Error("Format Error: Input has multiple REDEEM_SCRIPT");inputCount.redeemScript=convert.inputs.redeemScript.decode(keyVal);break;case typeFields_1.InputTypes.WITNESS_SCRIPT:checkKeyBuffer("input",
keyVal.key,typeFields_1.InputTypes.WITNESS_SCRIPT);if(void 0!==inputCount.witnessScript)throw Error("Format Error: Input has multiple WITNESS_SCRIPT");inputCount.witnessScript=convert.inputs.witnessScript.decode(keyVal);break;case typeFields_1.InputTypes.BIP32_DERIVATION:void 0===inputCount.bip32Derivation&&(inputCount.bip32Derivation=[]);inputCount.bip32Derivation.push(convert.inputs.bip32Derivation.decode(keyVal));break;case typeFields_1.InputTypes.FINAL_SCRIPTSIG:checkKeyBuffer("input",keyVal.key,
typeFields_1.InputTypes.FINAL_SCRIPTSIG);inputCount.finalScriptSig=convert.inputs.finalScriptSig.decode(keyVal);break;case typeFields_1.InputTypes.FINAL_SCRIPTWITNESS:checkKeyBuffer("input",keyVal.key,typeFields_1.InputTypes.FINAL_SCRIPTWITNESS);inputCount.finalScriptWitness=convert.inputs.finalScriptWitness.decode(keyVal);break;case typeFields_1.InputTypes.POR_COMMITMENT:checkKeyBuffer("input",keyVal.key,typeFields_1.InputTypes.POR_COMMITMENT);inputCount.porCommitment=convert.inputs.porCommitment.decode(keyVal);
break;case typeFields_1.InputTypes.TAP_KEY_SIG:checkKeyBuffer("input",keyVal.key,typeFields_1.InputTypes.TAP_KEY_SIG);inputCount.tapKeySig=convert.inputs.tapKeySig.decode(keyVal);break;case typeFields_1.InputTypes.TAP_SCRIPT_SIG:void 0===inputCount.tapScriptSig&&(inputCount.tapScriptSig=[]);inputCount.tapScriptSig.push(convert.inputs.tapScriptSig.decode(keyVal));break;case typeFields_1.InputTypes.TAP_LEAF_SCRIPT:void 0===inputCount.tapLeafScript&&(inputCount.tapLeafScript=[]);inputCount.tapLeafScript.push(convert.inputs.tapLeafScript.decode(keyVal));
break;case typeFields_1.InputTypes.TAP_BIP32_DERIVATION:void 0===inputCount.tapBip32Derivation&&(inputCount.tapBip32Derivation=[]);inputCount.tapBip32Derivation.push(convert.inputs.tapBip32Derivation.decode(keyVal));break;case typeFields_1.InputTypes.TAP_INTERNAL_KEY:checkKeyBuffer("input",keyVal.key,typeFields_1.InputTypes.TAP_INTERNAL_KEY);inputCount.tapInternalKey=convert.inputs.tapInternalKey.decode(keyVal);break;case typeFields_1.InputTypes.TAP_MERKLE_ROOT:checkKeyBuffer("input",keyVal.key,typeFields_1.InputTypes.TAP_MERKLE_ROOT);
inputCount.tapMerkleRoot=convert.inputs.tapMerkleRoot.decode(keyVal);break;default:inputCount.unknownKeyVals||(inputCount.unknownKeyVals=[]),inputCount.unknownKeyVals.push(keyVal)}globalMapKeyVals.push(inputCount)}for(const index of tools_1.range(txCount)){inputKeyVals={};for(const keyVal of outputKeyVals[index])switch(convert.outputs.checkPubkey(keyVal),keyVal.key[0]){case typeFields_1.OutputTypes.REDEEM_SCRIPT:checkKeyBuffer("output",keyVal.key,typeFields_1.OutputTypes.REDEEM_SCRIPT);if(void 0!==
inputKeyVals.redeemScript)throw Error("Format Error: Output has multiple REDEEM_SCRIPT");inputKeyVals.redeemScript=convert.outputs.redeemScript.decode(keyVal);break;case typeFields_1.OutputTypes.WITNESS_SCRIPT:checkKeyBuffer("output",keyVal.key,typeFields_1.OutputTypes.WITNESS_SCRIPT);if(void 0!==inputKeyVals.witnessScript)throw Error("Format Error: Output has multiple WITNESS_SCRIPT");inputKeyVals.witnessScript=convert.outputs.witnessScript.decode(keyVal);break;case typeFields_1.OutputTypes.BIP32_DERIVATION:void 0===
inputKeyVals.bip32Derivation&&(inputKeyVals.bip32Derivation=[]);inputKeyVals.bip32Derivation.push(convert.outputs.bip32Derivation.decode(keyVal));break;case typeFields_1.OutputTypes.TAP_INTERNAL_KEY:checkKeyBuffer("output",keyVal.key,typeFields_1.OutputTypes.TAP_INTERNAL_KEY);inputKeyVals.tapInternalKey=convert.outputs.tapInternalKey.decode(keyVal);break;case typeFields_1.OutputTypes.TAP_TREE:checkKeyBuffer("output",keyVal.key,typeFields_1.OutputTypes.TAP_TREE);inputKeyVals.tapTree=convert.outputs.tapTree.decode(keyVal);
break;case typeFields_1.OutputTypes.TAP_BIP32_DERIVATION:void 0===inputKeyVals.tapBip32Derivation&&(inputKeyVals.tapBip32Derivation=[]);inputKeyVals.tapBip32Derivation.push(convert.outputs.tapBip32Derivation.decode(keyVal));break;default:inputKeyVals.unknownKeyVals||(inputKeyVals.unknownKeyVals=[]),inputKeyVals.unknownKeyVals.push(keyVal)}keyVal$jscomp$0.push(inputKeyVals)}return{globalMap:unsignedTx,inputs:globalMapKeyVals,outputs:keyVal$jscomp$0}}var Buffer=require("module$node_modules$buffer$index").Buffer;
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const convert=require("module$node_modules$bip174$src$lib$converter$index"),tools_1=require("module$node_modules$bip174$src$lib$converter$tools"),varuint=require("module$node_modules$bip174$src$lib$converter$varint"),typeFields_1=require("module$node_modules$bip174$src$lib$typeFields");exports.psbtFromBuffer=function(buffer,txGetter){function varSlice(){const keyLen=varuint.decode(buffer,offset);offset+=varuint.encodingLength(keyLen);
const key=buffer.slice(offset,offset+keyLen);offset+=keyLen;return key}function getKeyValue(){const key=varSlice(),value=varSlice();return{key,value}}function checkEndOfKeyValPairs(){if(offset>=buffer.length)throw Error("Format Error: Unexpected End of PSBT");const isEnd=0===buffer.readUInt8(offset);isEnd&&offset++;return isEnd}let offset=0;if(1886610036!==function(){const num=buffer.readUInt32BE(offset);offset+=4;return num}())throw Error("Format Error: Invalid Magic Number");if(255!==function(){const num=
buffer.readUInt8(offset);offset+=1;return num}())throw Error("Format Error: Magic Number must be followed by 0xff separator");const globalMapKeyVals=[];for(var globalKeyIndex={};!checkEndOfKeyValPairs();){var keyVal$jscomp$0=getKeyValue(),hexKey=keyVal$jscomp$0.key.toString("hex");if(globalKeyIndex[hexKey])throw Error("Format Error: Keys must be unique for global keymap: key "+hexKey);globalKeyIndex[hexKey]=1;globalMapKeyVals.push(keyVal$jscomp$0)}globalKeyIndex=globalMapKeyVals.filter(keyVal=>keyVal.key[0]===
typeFields_1.GlobalTypes.UNSIGNED_TX);if(1!==globalKeyIndex.length)throw Error("Format Error: Only one UNSIGNED_TX allowed");txGetter=txGetter(globalKeyIndex[0].value);const {inputCount,outputCount}=txGetter.getInputOutputCounts();globalKeyIndex=[];keyVal$jscomp$0=[];for(var index$jscomp$0 of tools_1.range(inputCount)){hexKey={};for(var input=[];!checkEndOfKeyValPairs();){var keyVal$jscomp$1=getKeyValue();const hexKey$jscomp$0=keyVal$jscomp$1.key.toString("hex");if(hexKey[hexKey$jscomp$0])throw Error("Format Error: Keys must be unique for each input: input index "+
index$jscomp$0+" key "+hexKey$jscomp$0);hexKey[hexKey$jscomp$0]=1;input.push(keyVal$jscomp$1)}globalKeyIndex.push(input)}for(const index of tools_1.range(outputCount)){index$jscomp$0={};for(hexKey=[];!checkEndOfKeyValPairs();){input=getKeyValue();keyVal$jscomp$1=input.key.toString("hex");if(index$jscomp$0[keyVal$jscomp$1])throw Error("Format Error: Keys must be unique for each output: output index "+index+" key "+keyVal$jscomp$1);index$jscomp$0[keyVal$jscomp$1]=1;hexKey.push(input)}keyVal$jscomp$0.push(hexKey)}return psbtFromKeyVals(txGetter,
{globalMapKeyVals,inputKeyVals:globalKeyIndex,outputKeyVals:keyVal$jscomp$0})};exports.checkKeyBuffer=checkKeyBuffer;exports.psbtFromKeyVals=psbtFromKeyVals}
//# sourceMappingURL=module$node_modules$bip174$src$lib$parser$fromBuffer.js.map
