{
"version":3,
"file":"module$node_modules$readable_stream$lib$_stream_transform.js",
"lineCount":6,
"mappings":"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",
"sources":["node_modules/readable-stream/lib/_stream_transform.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$readable_stream$lib$_stream_transform\"] = function(global,require,module,exports) {\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n'use strict';\n\nmodule.exports = Transform;\n\nvar _require$codes = require('../errors').codes,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,\n    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;\n\nvar Duplex = require('./_stream_duplex');\n\nrequire('inherits')(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n  var cb = ts.writecb;\n\n  if (cb === null) {\n    return this.emit('error', new ERR_MULTIPLE_CALLBACK());\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n  cb(er);\n  var rs = this._readableState;\n  rs.reading = false;\n\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n  Duplex.call(this, options);\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  }; // start out asking for a readable event once data is transformed.\n\n  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  } // When the writable side finishes, then flush out anything remaining.\n\n\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function' && !this._readableState.destroyed) {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n}; // This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\n\n\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n}; // Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\n\n\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && !ts.transforming) {\n    ts.transforming = true;\n\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n\n  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();\n  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();\n  return stream.push(null);\n}\n};"],
"names":["shadow$provide","global","require","module","exports","afterTransform","er","data","ts","_transformState","transforming","cb","writecb","emit","ERR_MULTIPLE_CALLBACK","writechunk","push","rs","_readableState","reading","needReadable","length","highWaterMark","_read","Transform","options","Duplex","call","bind","needTransform","writeencoding","sync","transform","_transform","flush","_flush","on","prefinish","_this","destroyed","done","stream","_writableState","ERR_TRANSFORM_WITH_LENGTH_0","ERR_TRANSFORM_ALREADY_TRANSFORMING","_require$codes","codes","ERR_METHOD_NOT_IMPLEMENTED","prototype","Transform.prototype.push","chunk","encoding","Transform.prototype._transform","_write","Transform.prototype._write","Transform.prototype._read","n","_destroy","Transform.prototype._destroy","err","err2"]
}
