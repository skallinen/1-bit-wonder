shadow$provide.module$node_modules$bitcoin_address_generator$node_modules$bitcoinjs_lib$src$block=function(global,require,module,exports){function Block(){this.version=1;this.merkleRoot=this.prevHash=null;this.nonce=this.bits=this.timestamp=0}const Buffer=require("module$node_modules$safe_buffer$index").Buffer,bcrypto=require("module$node_modules$bitcoin_address_generator$node_modules$bitcoinjs_lib$src$crypto"),fastMerkleRoot=require("module$node_modules$merkle_lib$fastRoot"),typeforce=require("module$node_modules$typeforce$index"),
types=require("module$node_modules$bitcoin_address_generator$node_modules$bitcoinjs_lib$src$types"),varuint=require("module$node_modules$varuint_bitcoin$index"),Transaction=require("module$node_modules$bitcoin_address_generator$node_modules$bitcoinjs_lib$src$transaction");Block.fromBuffer=function(buffer){function readSlice(n){offset+=n;return buffer.slice(offset-n,offset)}function readUInt32(){const i=buffer.readUInt32LE(offset);offset+=4;return i}function readTransaction(){const tx=Transaction.fromBuffer(buffer.slice(offset),
!0);offset+=tx.byteLength();return tx}if(80>buffer.length)throw Error("Buffer too small (\x3c 80 bytes)");let offset=0;const block=new Block;block.version=function(){const i=buffer.readInt32LE(offset);offset+=4;return i}();block.prevHash=readSlice(32);block.merkleRoot=readSlice(32);block.timestamp=readUInt32();block.bits=readUInt32();block.nonce=readUInt32();if(80===buffer.length)return block;const nTransactions=function(){const vi=varuint.decode(buffer,offset);offset+=varuint.decode.bytes;return vi}();
block.transactions=[];for(var i$jscomp$0=0;i$jscomp$0<nTransactions;++i$jscomp$0){const tx=readTransaction();block.transactions.push(tx)}return block};Block.prototype.byteLength=function(headersOnly){return headersOnly||!this.transactions?80:80+varuint.encodingLength(this.transactions.length)+this.transactions.reduce(function(a,x){return a+x.byteLength()},0)};Block.fromHex=function(hex){return Block.fromBuffer(Buffer.from(hex,"hex"))};Block.prototype.getHash=function(){return bcrypto.hash256(this.toBuffer(!0))};
Block.prototype.getId=function(){return this.getHash().reverse().toString("hex")};Block.prototype.getUTCDate=function(){const date=new Date(0);date.setUTCSeconds(this.timestamp);return date};Block.prototype.toBuffer=function(headersOnly){function writeSlice(slice){slice.copy(buffer,offset);offset+=slice.length}function writeUInt32(i){buffer.writeUInt32LE(i,offset);offset+=4}const buffer=Buffer.allocUnsafe(this.byteLength(headersOnly));let offset=0;buffer.writeInt32LE(this.version,offset);offset+=
4;writeSlice(this.prevHash);writeSlice(this.merkleRoot);writeUInt32(this.timestamp);writeUInt32(this.bits);writeUInt32(this.nonce);if(headersOnly||!this.transactions)return buffer;varuint.encode(this.transactions.length,buffer,offset);offset+=varuint.encode.bytes;this.transactions.forEach(function(tx){const txSize=tx.byteLength();tx.toBuffer(buffer,offset);offset+=txSize});return buffer};Block.prototype.toHex=function(headersOnly){return this.toBuffer(headersOnly).toString("hex")};Block.calculateTarget=
function(bits){const exponent=((bits&4278190080)>>24)-3;bits&=8388607;const target=Buffer.alloc(32,0);target.writeUIntBE(bits,29-exponent,3);return target};Block.calculateMerkleRoot=function(transactions){typeforce([{getHash:types.Function}],transactions);if(0===transactions.length)throw TypeError("Cannot compute merkle root for zero transactions");transactions=transactions.map(function(transaction){return transaction.getHash()});return fastMerkleRoot(transactions,bcrypto.hash256)};Block.prototype.checkMerkleRoot=
function(){if(!this.transactions)return!1;const actualMerkleRoot=Block.calculateMerkleRoot(this.transactions);return 0===this.merkleRoot.compare(actualMerkleRoot)};Block.prototype.checkProofOfWork=function(){const hash=this.getHash().reverse(),target=Block.calculateTarget(this.bits);return 0>=hash.compare(target)};module.exports=Block}
//# sourceMappingURL=module$node_modules$bitcoin_address_generator$node_modules$bitcoinjs_lib$src$block.js.map
