shadow$provide.module$node_modules$bitcoinjs_lib$src$block=function(global,require,module,exports){function txesHaveWitnessCommit(transactions){return transactions instanceof Array&&transactions[0]&&transactions[0].ins&&transactions[0].ins instanceof Array&&transactions[0].ins[0]&&transactions[0].ins[0].witness&&transactions[0].ins[0].witness instanceof Array&&0<transactions[0].ins[0].witness.length}function anyTxHasWitness(transactions){return transactions instanceof Array&&transactions.some(tx=>
"object"===typeof tx&&tx.ins instanceof Array&&tx.ins.some(input=>"object"===typeof input&&input.witness instanceof Array&&0<input.witness.length))}var Buffer=require("module$node_modules$buffer$index").Buffer;"use strict";Object.defineProperty(exports,"__esModule",{value:!0});exports.Block=void 0;const bufferutils_1=require("module$node_modules$bitcoinjs_lib$src$bufferutils"),bcrypto=require("module$node_modules$bitcoinjs_lib$src$crypto"),merkle_1=require("module$node_modules$bitcoinjs_lib$src$merkle"),
transaction_1=require("module$node_modules$bitcoinjs_lib$src$transaction"),types=require("module$node_modules$bitcoinjs_lib$src$types"),{typeforce}=types,errorMerkleNoTxes=new TypeError("Cannot compute merkle root for zero transactions"),errorWitnessNotSegwit=new TypeError("Cannot compute witness commit for non-segwit block");class Block{constructor(){this.version=1;this.merkleRoot=this.prevHash=void 0;this.timestamp=0;this.witnessCommit=void 0;this.nonce=this.bits=0;this.transactions=void 0}static fromBuffer(buffer){if(80>
buffer.length)throw Error("Buffer too small (\x3c 80 bytes)");var bufferReader=new bufferutils_1.BufferReader(buffer);const block=new Block;block.version=bufferReader.readInt32();block.prevHash=bufferReader.readSlice(32);block.merkleRoot=bufferReader.readSlice(32);block.timestamp=bufferReader.readUInt32();block.bits=bufferReader.readUInt32();block.nonce=bufferReader.readUInt32();if(80===buffer.length)return block;buffer=bufferReader.readVarInt();block.transactions=[];for(let i=0;i<buffer;++i){const tx=
transaction_1.Transaction.fromBuffer(bufferReader.buffer.slice(bufferReader.offset),!0);bufferReader.offset+=tx.byteLength();block.transactions.push(tx)}if(bufferReader=block.getWitnessCommit())block.witnessCommit=bufferReader;return block}static fromHex(hex){return Block.fromBuffer(Buffer.from(hex,"hex"))}static calculateTarget(bits){const exponent=((bits&4278190080)>>24)-3;bits&=8388607;const target=Buffer.alloc(32,0);target.writeUIntBE(bits,29-exponent,3);return target}static calculateMerkleRoot(transactions,
forWitness){typeforce([{getHash:types.Function}],transactions);if(0===transactions.length)throw errorMerkleNoTxes;if(forWitness&&!txesHaveWitnessCommit(transactions))throw errorWitnessNotSegwit;var hashes=transactions.map(transaction=>transaction.getHash(forWitness));hashes=(0,merkle_1.fastMerkleRoot)(hashes,bcrypto.hash256);return forWitness?bcrypto.hash256(Buffer.concat([hashes,transactions[0].ins[0].witness[0]])):hashes}getWitnessCommit(){if(!txesHaveWitnessCommit(this.transactions))return null;
var witnessCommits=this.transactions[0].outs.filter(out=>out.script.slice(0,6).equals(Buffer.from("6a24aa21a9ed","hex"))).map(out=>out.script.slice(6,38));if(0===witnessCommits.length)return null;witnessCommits=witnessCommits[witnessCommits.length-1];return witnessCommits instanceof Buffer&&32===witnessCommits.length?witnessCommits:null}hasWitnessCommit(){return this.witnessCommit instanceof Buffer&&32===this.witnessCommit.length||null!==this.getWitnessCommit()?!0:!1}hasWitness(){return anyTxHasWitness(this.transactions)}weight(){const base=
this.byteLength(!1,!1),total=this.byteLength(!1,!0);return 3*base+total}byteLength(headersOnly,allowWitness=!0){return headersOnly||!this.transactions?80:80+bufferutils_1.varuint.encodingLength(this.transactions.length)+this.transactions.reduce((a,x)=>a+x.byteLength(allowWitness),0)}getHash(){return bcrypto.hash256(this.toBuffer(!0))}getId(){return(0,bufferutils_1.reverseBuffer)(this.getHash()).toString("hex")}getUTCDate(){const date=new Date(0);date.setUTCSeconds(this.timestamp);return date}toBuffer(headersOnly){const buffer=
Buffer.allocUnsafe(this.byteLength(headersOnly)),bufferWriter=new bufferutils_1.BufferWriter(buffer);bufferWriter.writeInt32(this.version);bufferWriter.writeSlice(this.prevHash);bufferWriter.writeSlice(this.merkleRoot);bufferWriter.writeUInt32(this.timestamp);bufferWriter.writeUInt32(this.bits);bufferWriter.writeUInt32(this.nonce);if(headersOnly||!this.transactions)return buffer;bufferutils_1.varuint.encode(this.transactions.length,buffer,bufferWriter.offset);bufferWriter.offset+=bufferutils_1.varuint.encode.bytes;
this.transactions.forEach(tx=>{const txSize=tx.byteLength();tx.toBuffer(buffer,bufferWriter.offset);bufferWriter.offset+=txSize});return buffer}toHex(headersOnly){return this.toBuffer(headersOnly).toString("hex")}checkTxRoots(){const hasWitnessCommit=this.hasWitnessCommit();return!hasWitnessCommit&&this.hasWitness()?!1:this.__checkMerkleRoot()&&(hasWitnessCommit?this.__checkWitnessCommit():!0)}checkProofOfWork(){const hash=(0,bufferutils_1.reverseBuffer)(this.getHash()),target=Block.calculateTarget(this.bits);
return 0>=hash.compare(target)}__checkMerkleRoot(){if(!this.transactions)throw errorMerkleNoTxes;const actualMerkleRoot=Block.calculateMerkleRoot(this.transactions);return 0===this.merkleRoot.compare(actualMerkleRoot)}__checkWitnessCommit(){if(!this.transactions)throw errorMerkleNoTxes;if(!this.hasWitnessCommit())throw errorWitnessNotSegwit;const actualWitnessCommit=Block.calculateMerkleRoot(this.transactions,!0);return 0===this.witnessCommit.compare(actualWitnessCommit)}}exports.Block=Block}
//# sourceMappingURL=module$node_modules$bitcoinjs_lib$src$block.js.map
