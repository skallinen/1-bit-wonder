shadow$provide.module$node_modules$bitcoinjs_lib$src$payments$p2pkh=function(global,require,module,exports){var Buffer=require("module$node_modules$buffer$index").Buffer;"use strict";Object.defineProperty(exports,"__esModule",{value:!0});exports.p2pkh=void 0;const bcrypto=require("module$node_modules$bitcoinjs_lib$src$crypto"),networks_1=require("module$node_modules$bitcoinjs_lib$src$networks"),bscript=require("module$node_modules$bitcoinjs_lib$src$script"),types_1=require("module$node_modules$bitcoinjs_lib$src$types"),
lazy=require("module$node_modules$bitcoinjs_lib$src$payments$lazy"),bs58check=require("module$node_modules$bs58check$index"),OPS=bscript.OPS;exports.p2pkh=function(a,opts){if(!(a.address||a.hash||a.output||a.pubkey||a.input))throw new TypeError("Not enough data");opts=Object.assign({validate:!0},opts||{});(0,types_1.typeforce)({network:types_1.typeforce.maybe(types_1.typeforce.Object),address:types_1.typeforce.maybe(types_1.typeforce.String),hash:types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),
output:types_1.typeforce.maybe(types_1.typeforce.BufferN(25)),pubkey:types_1.typeforce.maybe(types_1.isPoint),signature:types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),input:types_1.typeforce.maybe(types_1.typeforce.Buffer)},a);const _address=lazy.value(()=>{var payload=bs58check.decode(a.address);const version=payload.readUInt8(0);payload=payload.slice(1);return{version,hash:payload}}),_chunks=lazy.value(()=>bscript.decompile(a.input)),network=a.network||networks_1.bitcoin,o={name:"p2pkh",
network};lazy.prop(o,"address",()=>{if(o.hash){var payload=Buffer.allocUnsafe(21);payload.writeUInt8(network.pubKeyHash,0);o.hash.copy(payload,1);return bs58check.encode(payload)}});lazy.prop(o,"hash",()=>{if(a.output)return a.output.slice(3,23);if(a.address)return _address().hash;if(a.pubkey||o.pubkey)return bcrypto.hash160(a.pubkey||o.pubkey)});lazy.prop(o,"output",()=>{if(o.hash)return bscript.compile([OPS.OP_DUP,OPS.OP_HASH160,o.hash,OPS.OP_EQUALVERIFY,OPS.OP_CHECKSIG])});lazy.prop(o,"pubkey",
()=>{if(a.input)return _chunks()[1]});lazy.prop(o,"signature",()=>{if(a.input)return _chunks()[0]});lazy.prop(o,"input",()=>{if(a.pubkey&&a.signature)return bscript.compile([a.signature,a.pubkey])});lazy.prop(o,"witness",()=>{if(o.input)return[]});if(opts.validate){opts=Buffer.from([]);if(a.address){if(_address().version!==network.pubKeyHash)throw new TypeError("Invalid version or Network mismatch");if(20!==_address().hash.length)throw new TypeError("Invalid address");opts=_address().hash}if(a.hash){if(0<
opts.length&&!opts.equals(a.hash))throw new TypeError("Hash mismatch");opts=a.hash}if(a.output){if(25!==a.output.length||a.output[0]!==OPS.OP_DUP||a.output[1]!==OPS.OP_HASH160||20!==a.output[2]||a.output[23]!==OPS.OP_EQUALVERIFY||a.output[24]!==OPS.OP_CHECKSIG)throw new TypeError("Output is invalid");var hash2=a.output.slice(3,23);if(0<opts.length&&!opts.equals(hash2))throw new TypeError("Hash mismatch");opts=hash2}if(a.pubkey){hash2=bcrypto.hash160(a.pubkey);if(0<opts.length&&!opts.equals(hash2))throw new TypeError("Hash mismatch");
opts=hash2}if(a.input){hash2=_chunks();if(2!==hash2.length)throw new TypeError("Input is invalid");if(!bscript.isCanonicalScriptSignature(hash2[0]))throw new TypeError("Input has invalid signature");if(!(0,types_1.isPoint)(hash2[1]))throw new TypeError("Input has invalid pubkey");if(a.signature&&!a.signature.equals(hash2[0]))throw new TypeError("Signature mismatch");if(a.pubkey&&!a.pubkey.equals(hash2[1]))throw new TypeError("Pubkey mismatch");hash2=bcrypto.hash160(hash2[1]);if(0<opts.length&&!opts.equals(hash2))throw new TypeError("Hash mismatch");
}}return Object.assign(o,a)}}
//# sourceMappingURL=module$node_modules$bitcoinjs_lib$src$payments$p2pkh.js.map
