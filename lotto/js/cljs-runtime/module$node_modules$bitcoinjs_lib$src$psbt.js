shadow$provide.module$node_modules$bitcoinjs_lib$src$psbt=function(global,require,module,exports){function checkCache(cache){if(!1!==cache.__UNSAFE_SIGN_NONSEGWIT)throw Error("Not BIP174 compliant, can not export");}function hasSigs(neededSigs,partialSig,pubkeys){if(!partialSig)return!1;pubkeys=pubkeys?pubkeys.map(pkey=>{const pubkey=compressPubkey(pkey);return partialSig.find(pSig=>pSig.pubkey.equals(pubkey))}).filter(v=>!!v):partialSig;if(pubkeys.length>neededSigs)throw Error("Too many signatures");
return pubkeys.length===neededSigs}function isFinalized(input){return!!input.finalScriptSig||!!input.finalScriptWitness}function bip32DerivationIsMine(root){return d=>d.masterFingerprint.equals(root.fingerprint)&&root.derivePath(d.path).publicKey.equals(d.pubkey)?!0:!1}function check32Bit(num){if("number"!==typeof num||num!==Math.floor(num)||4294967295<num||0>num)throw Error("Invalid 32 bit integer");}function checkInputsForPartialSig(inputs,action){inputs.forEach(input=>{if((0,bip371_1.isTaprootInput)(input)?
(0,bip371_1.checkTaprootInputForSigs)(input,action):(0,psbtutils_1.checkInputForSig)(input,action))throw Error("Can not modify transaction, signatures exist.");})}function checkPartialSigSighashes(input){if(input.sighashType&&input.partialSig){var {partialSig,sighashType}=input;partialSig.forEach(pSig=>{({hashType:pSig}=bscript.signature.decode(pSig.signature));if(sighashType!==pSig)throw Error("Signature sighash does not match input sighash type");})}}function checkScriptForPubkey(pubkey,script,
action){if(!(0,psbtutils_1.pubkeyInScript)(pubkey,script))throw Error(`Can not ${action} for this input with the key ${pubkey.toString("hex")}`);}function checkTxEmpty(tx){if(!tx.ins.every(input=>input.script&&0===input.script.length&&input.witness&&0===input.witness.length))throw Error("Format Error: Transaction ScriptSigs are not empty");}function checkTxForDupeIns(tx,cache){tx.ins.forEach(input=>{checkTxInputCache(cache,input)})}function checkTxInputCache(cache,input){input=(0,bufferutils_1.reverseBuffer)(Buffer.from(input.hash)).toString("hex")+
":"+input.index;if(cache.__TX_IN_CACHE[input])throw Error("Duplicate input detected.");cache.__TX_IN_CACHE[input]=1}function scriptCheckerFactory(payment,paymentScriptName){return(inputIndex,scriptPubKey,redeemScript,ioType)=>{redeemScript=payment({redeem:{output:redeemScript}}).output;if(!scriptPubKey.equals(redeemScript))throw Error(`${paymentScriptName} for ${ioType} #${inputIndex} doesn't match the scriptPubKey in the prevout`);}}function getTxCacheValue(key,name,inputs,c){if(!inputs.every(isFinalized))throw Error(`PSBT must be finalized to calculate ${name}`);
if("__FEE_RATE"===key&&c.__FEE_RATE)return c.__FEE_RATE;if("__FEE"===key&&c.__FEE)return c.__FEE;let mustFinalize=!0;c.__EXTRACTED_TX?(name=c.__EXTRACTED_TX,mustFinalize=!1):name=c.__TX.clone();inputFinalizeGetAmts(inputs,name,c,mustFinalize);if("__FEE_RATE"===key)return c.__FEE_RATE;if("__FEE"===key)return c.__FEE}function getFinalScripts(inputIndex,input,script,isSegwit,isP2SH,isP2WSH){var scriptType=classifyScript(script);a:switch(scriptType){case "pubkey":case "pubkeyhash":case "witnesspubkeyhash":var JSCompiler_inline_result=
hasSigs(1,input.partialSig);break a;case "multisig":JSCompiler_inline_result=payments.p2ms({output:script});JSCompiler_inline_result=hasSigs(JSCompiler_inline_result.m,input.partialSig,JSCompiler_inline_result.pubkeys);break a;default:JSCompiler_inline_result=!1}if(!JSCompiler_inline_result)throw Error(`Can not finalize input #${inputIndex}`);let finalScriptSig,finalScriptWitness;inputIndex=input.partialSig;let payment;switch(scriptType){case "multisig":scriptType=getSortedSigs(script,inputIndex);
payment=payments.p2ms({output:script,signatures:scriptType});break;case "pubkey":payment=payments.p2pk({output:script,signature:inputIndex[0].signature});break;case "pubkeyhash":payment=payments.p2pkh({output:script,pubkey:inputIndex[0].pubkey,signature:inputIndex[0].signature});break;case "witnesspubkeyhash":payment=payments.p2wpkh({output:script,pubkey:inputIndex[0].pubkey,signature:inputIndex[0].signature})}script=payment;isP2WSH=isP2WSH?payments.p2wsh({redeem:script}):null;isP2SH=isP2SH?payments.p2sh({redeem:isP2WSH||
script}):null;isSegwit?(finalScriptWitness=isP2WSH?(0,psbtutils_1.witnessStackToScriptWitness)(isP2WSH.witness):(0,psbtutils_1.witnessStackToScriptWitness)(script.witness),isP2SH&&(finalScriptSig=isP2SH.input)):finalScriptSig=isP2SH?isP2SH.input:script.input;return{finalScriptSig,finalScriptWitness}}function getHashAndSighashType(inputs,inputIndex,pubkey,cache,sighashTypes){inputs=(0,utils_1.checkForInput)(inputs,inputIndex);const {hash,sighashType,script}=getHashForSig(inputIndex,inputs,cache,!1,
sighashTypes);checkScriptForPubkey(pubkey,script,"sign");return{hash,sighashType}}function getHashForSig(inputIndex,input,cache,forValidate,sighashTypes){const unsignedTx=cache.__TX,sighashType=input.sighashType||transaction_1.Transaction.SIGHASH_ALL;checkSighashTypeAllowed(sighashType,sighashTypes);if(input.nonWitnessUtxo){sighashTypes=nonWitnessUtxoTxFromCache(cache,input,inputIndex);const prevoutHash=unsignedTx.ins[inputIndex].hash,utxoHash=sighashTypes.getHash();if(!prevoutHash.equals(utxoHash))throw Error(`Non-witness UTXO hash for input #${inputIndex} doesn't match the hash specified in the prevout`);
sighashTypes=sighashTypes.outs[unsignedTx.ins[inputIndex].index]}else if(input.witnessUtxo)sighashTypes=input.witnessUtxo;else throw Error("Need a Utxo input item for signing");const {meaningfulScript,type}=getMeaningfulScript(sighashTypes.script,inputIndex,"input",input.redeemScript,input.witnessScript);if(0<=["p2sh-p2wsh","p2wsh"].indexOf(type))inputIndex=unsignedTx.hashForWitnessV0(inputIndex,meaningfulScript,sighashTypes.value,sighashType);else if((0,psbtutils_1.isP2WPKH)(meaningfulScript))input=
payments.p2pkh({hash:meaningfulScript.slice(2)}).output,inputIndex=unsignedTx.hashForWitnessV0(inputIndex,input,sighashTypes.value,sighashType);else{if(void 0===input.nonWitnessUtxo&&!1===cache.__UNSAFE_SIGN_NONSEGWIT)throw Error(`Input #${inputIndex} has witnessUtxo but non-segwit script: `+`${meaningfulScript.toString("hex")}`);forValidate||!1===cache.__UNSAFE_SIGN_NONSEGWIT||console.warn("Warning: Signing non-segwit inputs without the full parent transaction means there is a chance that a miner could feed you incorrect information to trick you into paying large fees. This behavior is the same as Psbt's predecesor (TransactionBuilder - now removed) when signing non-segwit scripts. You are not able to export this Psbt with toBuffer|toBase64|toHex since it is not BIP174 compliant.\n*********************\nPROCEED WITH CAUTION!\n*********************");
inputIndex=unsignedTx.hashForSignature(inputIndex,meaningfulScript,sighashType)}return{script:meaningfulScript,sighashType,hash:inputIndex}}function getAllTaprootHashesForSig(inputIndex,input,inputs,cache){const allPublicKeys=[];if(input.tapInternalKey){var outputKey=(0,bip371_1.tweakInternalPubKey)(inputIndex,input);allPublicKeys.push(outputKey)}input.tapScriptSig&&(outputKey=input.tapScriptSig.map(tss=>tss.pubkey),allPublicKeys.push(...outputKey));return allPublicKeys.map(pubicKey=>getTaprootHashesForSig(inputIndex,
input,inputs,pubicKey,cache)).flat()}function getTaprootHashesForSig(inputIndex,input,inputs,pubkey,cache,tapLeafHashToSign,allowedSighashTypes){const unsignedTx=cache.__TX;var sighashType=input.sighashType||transaction_1.Transaction.SIGHASH_DEFAULT;checkSighashTypeAllowed(sighashType,allowedSighashTypes);inputs=inputs.map((i,index)=>getScriptAndAmountFromUtxo(index,i,cache));const signingScripts=inputs.map(o=>o.script),values=inputs.map(o=>o.value);inputs=[];input.tapInternalKey&&!tapLeafHashToSign&&
(allowedSighashTypes=(0,bip371_1.tweakInternalPubKey)(inputIndex,input),(0,bip371_1.toXOnly)(pubkey).equals(allowedSighashTypes)&&(sighashType=unsignedTx.hashForWitnessV1(inputIndex,signingScripts,values,sighashType),inputs.push({pubkey,hash:sighashType})));input=(input.tapLeafScript||[]).filter(tapLeaf=>(0,psbtutils_1.pubkeyInScript)(pubkey,tapLeaf.script)).map(tapLeaf=>{const hash=(0,bip341_1.tapleafHash)({output:tapLeaf.script,version:tapLeaf.leafVersion});return Object.assign({hash},tapLeaf)}).filter(tapLeaf=>
!tapLeafHashToSign||tapLeafHashToSign.equals(tapLeaf.hash)).map(tapLeaf=>{const tapScriptHash=unsignedTx.hashForWitnessV1(inputIndex,signingScripts,values,transaction_1.Transaction.SIGHASH_DEFAULT,tapLeaf.hash);return{pubkey,hash:tapScriptHash,leafHash:tapLeaf.hash}});return inputs.concat(input)}function checkSighashTypeAllowed(sighashType,sighashTypes){if(sighashTypes&&0>sighashTypes.indexOf(sighashType)){sighashTypes=sighashType&transaction_1.Transaction.SIGHASH_ANYONECANPAY?"SIGHASH_ANYONECANPAY | ":
"";switch(sighashType&31){case transaction_1.Transaction.SIGHASH_ALL:sighashTypes+="SIGHASH_ALL";break;case transaction_1.Transaction.SIGHASH_SINGLE:sighashTypes+="SIGHASH_SINGLE";break;case transaction_1.Transaction.SIGHASH_NONE:sighashTypes+="SIGHASH_NONE"}throw Error("Sighash type is not allowed. Retry the sign method passing the "+`sighashTypes array of whitelisted types. Sighash type: ${sighashTypes}`);}}function getSignersFromHD(inputIndex,inputs,hdKeyPair){inputIndex=(0,utils_1.checkForInput)(inputs,
inputIndex);if(!inputIndex.bip32Derivation||0===inputIndex.bip32Derivation.length)throw Error("Need bip32Derivation to sign with HD");inputIndex=inputIndex.bip32Derivation.map(bipDv=>{if(bipDv.masterFingerprint.equals(hdKeyPair.fingerprint))return bipDv}).filter(v=>!!v);if(0===inputIndex.length)throw Error("Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint");return inputIndex.map(bipDv=>{const node=hdKeyPair.derivePath(bipDv.path);if(!bipDv.pubkey.equals(node.publicKey))throw Error("pubkey did not match bip32Derivation");
return node})}function getSortedSigs(script,partialSig){return payments.p2ms({output:script}).pubkeys.map(pk=>(partialSig.filter(ps=>ps.pubkey.equals(pk))[0]||{}).signature).filter(v=>!!v)}function scriptWitnessToWitnessStack(buffer){function readVarInt(){const vi=varuint.decode(buffer,offset);offset+=varuint.decode.bytes;return vi}let offset=0;return function(){const count=readVarInt(),vector=[];for(let i=0;i<count;i++){var JSCompiler_temp_const=vector,JSCompiler_temp_const$jscomp$0=JSCompiler_temp_const.push;
var JSCompiler_inline_result=readVarInt();offset+=JSCompiler_inline_result;JSCompiler_inline_result=buffer.slice(offset-JSCompiler_inline_result,offset);JSCompiler_temp_const$jscomp$0.call(JSCompiler_temp_const,JSCompiler_inline_result)}return vector}()}function addNonWitnessTxCache(cache,input,inputIndex){cache.__NON_WITNESS_UTXO_BUF_CACHE[inputIndex]=input.nonWitnessUtxo;const tx=transaction_1.Transaction.fromBuffer(input.nonWitnessUtxo);cache.__NON_WITNESS_UTXO_TX_CACHE[inputIndex]=tx;delete input.nonWitnessUtxo;
Object.defineProperty(input,"nonWitnessUtxo",{enumerable:!0,get(){var buf=cache.__NON_WITNESS_UTXO_BUF_CACHE[inputIndex];if(void 0!==buf)return buf;buf=cache.__NON_WITNESS_UTXO_TX_CACHE[inputIndex].toBuffer();return cache.__NON_WITNESS_UTXO_BUF_CACHE[inputIndex]=buf},set(data){cache.__NON_WITNESS_UTXO_BUF_CACHE[inputIndex]=data}})}function inputFinalizeGetAmts(inputs,tx,cache,mustFinalize){let inputAmount=0;inputs.forEach((input,idx)=>{mustFinalize&&input.finalScriptSig&&(tx.ins[idx].script=input.finalScriptSig);
mustFinalize&&input.finalScriptWitness&&(tx.ins[idx].witness=scriptWitnessToWitnessStack(input.finalScriptWitness));input.witnessUtxo?inputAmount+=input.witnessUtxo.value:input.nonWitnessUtxo&&(input=nonWitnessUtxoTxFromCache(cache,input,idx),inputAmount+=input.outs[tx.ins[idx].index].value)});inputs=tx.outs.reduce((total,o)=>total+o.value,0);inputs=inputAmount-inputs;if(0>inputs)throw Error("Outputs are spending more than Inputs");const bytes=tx.virtualSize();cache.__FEE=inputs;cache.__EXTRACTED_TX=
tx;cache.__FEE_RATE=Math.floor(inputs/bytes)}function nonWitnessUtxoTxFromCache(cache,input,inputIndex){const c=cache.__NON_WITNESS_UTXO_TX_CACHE;c[inputIndex]||addNonWitnessTxCache(cache,input,inputIndex);return c[inputIndex]}function getScriptFromUtxo(inputIndex,input,cache){({script:inputIndex}=getScriptAndAmountFromUtxo(inputIndex,input,cache));return inputIndex}function getScriptAndAmountFromUtxo(inputIndex,input,cache){if(void 0!==input.witnessUtxo)return{script:input.witnessUtxo.script,value:input.witnessUtxo.value};
if(void 0!==input.nonWitnessUtxo)return inputIndex=nonWitnessUtxoTxFromCache(cache,input,inputIndex).outs[cache.__TX.ins[inputIndex].index],{script:inputIndex.script,value:inputIndex.value};throw Error("Can't find pubkey in input without Utxo data");}function compressPubkey(pubkey){if(65===pubkey.length){const parity=pubkey[64]&1;pubkey=pubkey.slice(0,33);pubkey[0]=2|parity;return pubkey}return pubkey.slice()}function getMeaningfulScript(script,index,ioType,redeemScript,witnessScript){const isP2SH=
(0,psbtutils_1.isP2SHScript)(script),isP2SHP2WSH=isP2SH&&redeemScript&&(0,psbtutils_1.isP2WSHScript)(redeemScript),isP2WSH=(0,psbtutils_1.isP2WSHScript)(script);if(isP2SH&&void 0===redeemScript)throw Error("scriptPubkey is P2SH but redeemScript missing");if((isP2WSH||isP2SHP2WSH)&&void 0===witnessScript)throw Error("scriptPubkey or redeemScript is P2WSH but witnessScript missing");let meaningfulScript;isP2SHP2WSH?(meaningfulScript=witnessScript,checkRedeemScript(index,script,redeemScript,ioType),
checkWitnessScript(index,redeemScript,witnessScript,ioType),checkInvalidP2WSH(meaningfulScript)):isP2WSH?(meaningfulScript=witnessScript,checkWitnessScript(index,script,witnessScript,ioType),checkInvalidP2WSH(meaningfulScript)):isP2SH?(meaningfulScript=redeemScript,checkRedeemScript(index,script,redeemScript,ioType)):meaningfulScript=script;return{meaningfulScript,type:isP2SHP2WSH?"p2sh-p2wsh":isP2SH?"p2sh":isP2WSH?"p2wsh":"raw"}}function checkInvalidP2WSH(script){if((0,psbtutils_1.isP2WPKH)(script)||
(0,psbtutils_1.isP2SHScript)(script))throw Error("P2WPKH or P2SH can not be contained within P2WSH");}function classifyScript(script){return(0,psbtutils_1.isP2WPKH)(script)?"witnesspubkeyhash":(0,psbtutils_1.isP2PKH)(script)?"pubkeyhash":(0,psbtutils_1.isP2MS)(script)?"multisig":(0,psbtutils_1.isP2PK)(script)?"pubkey":"nonstandard"}function range(n){return[...Array(n).keys()]}var Buffer=require("module$node_modules$buffer$index").Buffer;"use strict";Object.defineProperty(exports,"__esModule",{value:!0});
exports.Psbt=void 0;const bip174_1=require("module$node_modules$bip174$src$lib$psbt"),varuint=require("module$node_modules$bip174$src$lib$converter$varint"),utils_1=require("module$node_modules$bip174$src$lib$utils"),address_1=require("module$node_modules$bitcoinjs_lib$src$address"),bufferutils_1=require("module$node_modules$bitcoinjs_lib$src$bufferutils");global=require("module$node_modules$bitcoinjs_lib$src$networks");const payments=require("module$node_modules$bitcoinjs_lib$src$payments$index"),
bip341_1=require("module$node_modules$bitcoinjs_lib$src$payments$bip341"),bscript=require("module$node_modules$bitcoinjs_lib$src$script"),transaction_1=require("module$node_modules$bitcoinjs_lib$src$transaction"),bip371_1=require("module$node_modules$bitcoinjs_lib$src$psbt$bip371"),psbtutils_1=require("module$node_modules$bitcoinjs_lib$src$psbt$psbtutils"),DEFAULT_OPTS={network:global.bitcoin,maximumFeeRate:5E3};class Psbt{static fromBase64(data,opts={}){data=Buffer.from(data,"base64");return this.fromBuffer(data,
opts)}static fromHex(data,opts={}){data=Buffer.from(data,"hex");return this.fromBuffer(data,opts)}static fromBuffer(buffer,opts={}){buffer=bip174_1.Psbt.fromBuffer(buffer,transactionFromBuffer);opts=new Psbt(opts,buffer);checkTxForDupeIns(opts.__CACHE.__TX,opts.__CACHE);return opts}constructor(opts={},data=new bip174_1.Psbt(new PsbtTransaction)){this.data=data;this.opts=Object.assign({},DEFAULT_OPTS,opts);this.__CACHE={__NON_WITNESS_UTXO_TX_CACHE:[],__NON_WITNESS_UTXO_BUF_CACHE:[],__TX_IN_CACHE:{},
__TX:this.data.globalMap.unsignedTx.tx,__UNSAFE_SIGN_NONSEGWIT:!1};0===this.data.inputs.length&&this.setVersion(2);Object.defineProperty(this,"__CACHE",{enumerable:!1,writable:!0});Object.defineProperty(this,"opts",{enumerable:!1,writable:!0})}get inputCount(){return this.data.inputs.length}get version(){return this.__CACHE.__TX.version}set version(version){this.setVersion(version)}get locktime(){return this.__CACHE.__TX.locktime}set locktime(locktime){this.setLocktime(locktime)}get txInputs(){return this.__CACHE.__TX.ins.map(input=>
({hash:(0,bufferutils_1.cloneBuffer)(input.hash),index:input.index,sequence:input.sequence}))}get txOutputs(){return this.__CACHE.__TX.outs.map(output=>{let address;try{address=(0,address_1.fromOutputScript)(output.script,this.opts.network)}catch(_){}return{script:(0,bufferutils_1.cloneBuffer)(output.script),value:output.value,address}})}combine(...those){this.data.combine(...those.map(o=>o.data));return this}clone(){const res=Psbt.fromBuffer(this.data.toBuffer());res.opts=JSON.parse(JSON.stringify(this.opts));
return res}setMaximumFeeRate(satoshiPerByte){check32Bit(satoshiPerByte);this.opts.maximumFeeRate=satoshiPerByte}setVersion(version){check32Bit(version);checkInputsForPartialSig(this.data.inputs,"setVersion");const c=this.__CACHE;c.__TX.version=version;c.__EXTRACTED_TX=void 0;return this}setLocktime(locktime){check32Bit(locktime);checkInputsForPartialSig(this.data.inputs,"setLocktime");const c=this.__CACHE;c.__TX.locktime=locktime;c.__EXTRACTED_TX=void 0;return this}setInputSequence(inputIndex,sequence){check32Bit(sequence);
checkInputsForPartialSig(this.data.inputs,"setInputSequence");const c=this.__CACHE;if(c.__TX.ins.length<=inputIndex)throw Error("Input index too high");c.__TX.ins[inputIndex].sequence=sequence;c.__EXTRACTED_TX=void 0;return this}addInputs(inputDatas){inputDatas.forEach(inputData=>this.addInput(inputData));return this}addInput(inputData){if(1<arguments.length||!inputData||void 0===inputData.hash||void 0===inputData.index)throw Error("Invalid arguments for Psbt.addInput. Requires single object with at least [hash] and [index]");
(0,bip371_1.checkTaprootInputFields)(inputData,inputData,"addInput");checkInputsForPartialSig(this.data.inputs,"addInput");inputData.witnessScript&&checkInvalidP2WSH(inputData.witnessScript);const c=this.__CACHE;this.data.addInput(inputData);checkTxInputCache(c,c.__TX.ins[c.__TX.ins.length-1]);const inputIndex=this.data.inputs.length-1,input=this.data.inputs[inputIndex];input.nonWitnessUtxo&&addNonWitnessTxCache(this.__CACHE,input,inputIndex);c.__FEE=void 0;c.__FEE_RATE=void 0;c.__EXTRACTED_TX=void 0;
return this}addOutputs(outputDatas){outputDatas.forEach(outputData=>this.addOutput(outputData));return this}addOutput(outputData){if(1<arguments.length||!outputData||void 0===outputData.value||void 0===outputData.address&&void 0===outputData.script)throw Error("Invalid arguments for Psbt.addOutput. Requires single object with at least [script or address] and [value]");checkInputsForPartialSig(this.data.inputs,"addOutput");var {address}=outputData;if("string"===typeof address){const {network}=this.opts;
address=(0,address_1.toOutputScript)(address,network);outputData=Object.assign(outputData,{script:address})}(0,bip371_1.checkTaprootOutputFields)(outputData,outputData,"addOutput");address=this.__CACHE;this.data.addOutput(outputData);address.__FEE=void 0;address.__FEE_RATE=void 0;address.__EXTRACTED_TX=void 0;return this}extractTransaction(disableFeeCheck){if(!this.data.inputs.every(isFinalized))throw Error("Not finalized");const c=this.__CACHE;if(!disableFeeCheck){disableFeeCheck=this.opts;const feeRate=
c.__FEE_RATE||this.getFeeRate(),vsize=c.__EXTRACTED_TX.virtualSize();if(feeRate>=disableFeeCheck.maximumFeeRate)throw Error(`Warning: You are paying around ${(feeRate*vsize/1E8).toFixed(8)} in `+`fees, which is ${feeRate} satoshi per byte for a transaction `+`with a VSize of ${vsize} bytes (segwit counted as 0.25 byte per `+"byte). Use setMaximumFeeRate method to raise your threshold, or pass true to the first arg of extractTransaction.");}if(c.__EXTRACTED_TX)return c.__EXTRACTED_TX;disableFeeCheck=
c.__TX.clone();inputFinalizeGetAmts(this.data.inputs,disableFeeCheck,c,!0);return disableFeeCheck}getFeeRate(){return getTxCacheValue("__FEE_RATE","fee rate",this.data.inputs,this.__CACHE)}getFee(){return getTxCacheValue("__FEE","fee",this.data.inputs,this.__CACHE)}finalizeAllInputs(){(0,utils_1.checkForInput)(this.data.inputs,0);range(this.data.inputs.length).forEach(idx=>this.finalizeInput(idx));return this}finalizeInput(inputIndex,finalScriptsFunc){const input=(0,utils_1.checkForInput)(this.data.inputs,
inputIndex);return(0,bip371_1.isTaprootInput)(input)?this._finalizeTaprootInput(inputIndex,input,void 0,finalScriptsFunc):this._finalizeInput(inputIndex,input,finalScriptsFunc)}finalizeTaprootInput(inputIndex,tapLeafHashToFinalize,finalScriptsFunc=bip371_1.tapScriptFinalizer){const input=(0,utils_1.checkForInput)(this.data.inputs,inputIndex);if((0,bip371_1.isTaprootInput)(input))return this._finalizeTaprootInput(inputIndex,input,tapLeafHashToFinalize,finalScriptsFunc);throw Error(`Cannot finalize input #${inputIndex}. Not Taproot.`);
}_finalizeInput(inputIndex,input,finalScriptsFunc=getFinalScripts){var cache=this.__CACHE;const unsignedTx=cache.__TX,res={script:null,isSegwit:!1,isP2SH:!1,isP2WSH:!1};res.isP2SH=!!input.redeemScript;res.isP2WSH=!!input.witnessScript;input.witnessScript?res.script=input.witnessScript:input.redeemScript?res.script=input.redeemScript:input.nonWitnessUtxo?(cache=nonWitnessUtxoTxFromCache(cache,input,inputIndex),res.script=cache.outs[unsignedTx.ins[inputIndex].index].script):input.witnessUtxo&&(res.script=
input.witnessUtxo.script);if(input.witnessScript||(0,psbtutils_1.isP2WPKH)(res.script))res.isSegwit=!0;const {script,isP2SH,isP2WSH,isSegwit}=res;if(!script)throw Error(`No script found for input #${inputIndex}`);checkPartialSigSighashes(input);const {finalScriptSig,finalScriptWitness}=finalScriptsFunc(inputIndex,input,script,isSegwit,isP2SH,isP2WSH);finalScriptSig&&this.data.updateInput(inputIndex,{finalScriptSig});finalScriptWitness&&this.data.updateInput(inputIndex,{finalScriptWitness});if(!finalScriptSig&&
!finalScriptWitness)throw Error(`Unknown error finalizing input #${inputIndex}`);this.data.clearFinalizedInput(inputIndex);return this}_finalizeTaprootInput(inputIndex,input,tapLeafHashToFinalize,finalScriptsFunc=bip371_1.tapScriptFinalizer){if(!input.witnessUtxo)throw Error(`Cannot finalize input #${inputIndex}. Missing withness utxo.`);input.tapKeySig?(input=payments.p2tr({output:input.witnessUtxo.script,signature:input.tapKeySig}),input=(0,psbtutils_1.witnessStackToScriptWitness)(input.witness),
this.data.updateInput(inputIndex,{finalScriptWitness:input})):({finalScriptWitness:input}=finalScriptsFunc(inputIndex,input,tapLeafHashToFinalize),this.data.updateInput(inputIndex,{finalScriptWitness:input}));this.data.clearFinalizedInput(inputIndex);return this}getInputType(inputIndex){var input=(0,utils_1.checkForInput)(this.data.inputs,inputIndex),script=getScriptFromUtxo(inputIndex,input,this.__CACHE),JSCompiler_temp;if(!(JSCompiler_temp=input.redeemScript))a:{if(JSCompiler_temp=input.finalScriptSig)if(JSCompiler_temp=
bscript.decompile(JSCompiler_temp))if(JSCompiler_temp=JSCompiler_temp[JSCompiler_temp.length-1],!(!Buffer.isBuffer(JSCompiler_temp)||33===JSCompiler_temp.length&&bscript.isCanonicalPubKey(JSCompiler_temp)||bscript.isCanonicalScriptSignature(JSCompiler_temp))&&bscript.decompile(JSCompiler_temp))break a;JSCompiler_temp=void 0}var JSCompiler_temp$jscomp$0;if(!(JSCompiler_temp$jscomp$0=input.witnessScript))a:{if(input=input.finalScriptWitness)if(input=scriptWitnessToWitnessStack(input),input=input[input.length-
1],(33!==input.length||!bscript.isCanonicalPubKey(input))&&bscript.decompile(input)){JSCompiler_temp$jscomp$0=input;break a}JSCompiler_temp$jscomp$0=void 0}script=getMeaningfulScript(script,inputIndex,"input",JSCompiler_temp,JSCompiler_temp$jscomp$0);inputIndex="raw"===script.type?"":script.type+"-";script=classifyScript(script.meaningfulScript);return inputIndex+script}inputHasPubkey(inputIndex,pubkey){const input=(0,utils_1.checkForInput)(this.data.inputs,inputIndex),script=getScriptFromUtxo(inputIndex,
input,this.__CACHE);({meaningfulScript:inputIndex}=getMeaningfulScript(script,inputIndex,"input",input.redeemScript,input.witnessScript));return(0,psbtutils_1.pubkeyInScript)(pubkey,inputIndex)}inputHasHDKey(inputIndex,root){inputIndex=(0,utils_1.checkForInput)(this.data.inputs,inputIndex);root=bip32DerivationIsMine(root);return!!inputIndex.bip32Derivation&&inputIndex.bip32Derivation.some(root)}outputHasPubkey(outputIndex,pubkey){const output=(0,utils_1.checkForOutput)(this.data.outputs,outputIndex);
({meaningfulScript:outputIndex}=getMeaningfulScript(this.__CACHE.__TX.outs[outputIndex].script,outputIndex,"output",output.redeemScript,output.witnessScript));return(0,psbtutils_1.pubkeyInScript)(pubkey,outputIndex)}outputHasHDKey(outputIndex,root){outputIndex=(0,utils_1.checkForOutput)(this.data.outputs,outputIndex);root=bip32DerivationIsMine(root);return!!outputIndex.bip32Derivation&&outputIndex.bip32Derivation.some(root)}validateSignaturesOfAllInputs(validator){(0,utils_1.checkForInput)(this.data.inputs,
0);return range(this.data.inputs.length).map(idx=>this.validateSignaturesOfInput(idx,validator)).reduce((final,res)=>!0===res&&final,!0)}validateSignaturesOfInput(inputIndex,validator,pubkey){return(0,bip371_1.isTaprootInput)(this.data.inputs[inputIndex])?this.validateSignaturesOfTaprootInput(inputIndex,validator,pubkey):this._validateSignaturesOfInput(inputIndex,validator,pubkey)}_validateSignaturesOfInput(inputIndex,validator,pubkey){const input=this.data.inputs[inputIndex];var partialSig=(input||
{}).partialSig;if(!input||!partialSig||1>partialSig.length)throw Error("No signatures to validate");if("function"!==typeof validator)throw Error("Need validator function to validate signatures");var mySigs=pubkey?partialSig.filter(sig=>sig.pubkey.equals(pubkey)):partialSig;if(1>mySigs.length)throw Error("No signatures for this pubkey");partialSig=[];let hashCache,scriptCache,sighashCache;for(const pSig of mySigs){mySigs=bscript.signature.decode(pSig.signature);const {hash,script}=sighashCache!==mySigs.hashType?
getHashForSig(inputIndex,Object.assign({},input,{sighashType:mySigs.hashType}),this.__CACHE,!0):{hash:hashCache,script:scriptCache};sighashCache=mySigs.hashType;hashCache=hash;scriptCache=script;checkScriptForPubkey(pSig.pubkey,script,"verify");partialSig.push(validator(pSig.pubkey,hash,mySigs.signature))}return partialSig.every(res=>!0===res)}validateSignaturesOfTaprootInput(inputIndex,validator,pubkey){const input=this.data.inputs[inputIndex];var tapKeySig=(input||{}).tapKeySig;const tapScriptSig=
(input||{}).tapScriptSig;if(!(input||tapKeySig||tapScriptSig&&!tapScriptSig.length))throw Error("No signatures to validate");if("function"!==typeof validator)throw Error("Need validator function to validate signatures");inputIndex=(pubkey=pubkey&&(0,bip371_1.toXOnly)(pubkey))?getTaprootHashesForSig(inputIndex,input,this.data.inputs,pubkey,this.__CACHE):getAllTaprootHashesForSig(inputIndex,input,this.data.inputs,this.__CACHE);if(!inputIndex.length)throw Error("No signatures for this pubkey");pubkey=
inputIndex.find(h=>!!h.leafHash);if(tapKeySig&&pubkey&&!validator(pubkey.pubkey,pubkey.hash,tapKeySig))return!1;if(tapScriptSig)for(const tapSig of tapScriptSig)if((tapKeySig=inputIndex.find(h=>tapSig.pubkey.equals(h.pubkey)))&&!validator(tapSig.pubkey,tapKeySig.hash,tapSig.signature))return!1;return!0}signAllInputsHD(hdKeyPair,sighashTypes=[transaction_1.Transaction.SIGHASH_ALL]){if(!hdKeyPair||!hdKeyPair.publicKey||!hdKeyPair.fingerprint)throw Error("Need HDSigner to sign input");const results=
[];for(const i of range(this.data.inputs.length))try{this.signInputHD(i,hdKeyPair,sighashTypes),results.push(!0)}catch(err){results.push(!1)}if(results.every(v=>!1===v))throw Error("No inputs were signed");return this}signAllInputsHDAsync(hdKeyPair,sighashTypes=[transaction_1.Transaction.SIGHASH_ALL]){return new Promise((resolve,reject)=>{if(!hdKeyPair||!hdKeyPair.publicKey||!hdKeyPair.fingerprint)return reject(Error("Need HDSigner to sign input"));const results=[],promises=[];for(const i of range(this.data.inputs.length))promises.push(this.signInputHDAsync(i,
hdKeyPair,sighashTypes).then(()=>{results.push(!0)},()=>{results.push(!1)}));return Promise.all(promises).then(()=>{if(results.every(v=>!1===v))return reject(Error("No inputs were signed"));resolve()})})}signInputHD(inputIndex,hdKeyPair,sighashTypes=[transaction_1.Transaction.SIGHASH_ALL]){if(!hdKeyPair||!hdKeyPair.publicKey||!hdKeyPair.fingerprint)throw Error("Need HDSigner to sign input");getSignersFromHD(inputIndex,this.data.inputs,hdKeyPair).forEach(signer=>this.signInput(inputIndex,signer,sighashTypes));
return this}signInputHDAsync(inputIndex,hdKeyPair,sighashTypes=[transaction_1.Transaction.SIGHASH_ALL]){return new Promise((resolve,reject)=>{if(!hdKeyPair||!hdKeyPair.publicKey||!hdKeyPair.fingerprint)return reject(Error("Need HDSigner to sign input"));const promises=getSignersFromHD(inputIndex,this.data.inputs,hdKeyPair).map(signer=>this.signInputAsync(inputIndex,signer,sighashTypes));return Promise.all(promises).then(()=>{resolve()}).catch(reject)})}signAllInputs(keyPair,sighashTypes){if(!keyPair||
!keyPair.publicKey)throw Error("Need Signer to sign input");const results=[];for(const i of range(this.data.inputs.length))try{this.signInput(i,keyPair,sighashTypes),results.push(!0)}catch(err){results.push(!1)}if(results.every(v=>!1===v))throw Error("No inputs were signed");return this}signAllInputsAsync(keyPair,sighashTypes){return new Promise((resolve,reject)=>{if(!keyPair||!keyPair.publicKey)return reject(Error("Need Signer to sign input"));const results=[],promises=[];for(const [i]of this.data.inputs.entries())promises.push(this.signInputAsync(i,
keyPair,sighashTypes).then(()=>{results.push(!0)},()=>{results.push(!1)}));return Promise.all(promises).then(()=>{if(results.every(v=>!1===v))return reject(Error("No inputs were signed"));resolve()})})}signInput(inputIndex,keyPair,sighashTypes){if(!keyPair||!keyPair.publicKey)throw Error("Need Signer to sign input");const input=(0,utils_1.checkForInput)(this.data.inputs,inputIndex);return(0,bip371_1.isTaprootInput)(input)?this._signTaprootInput(inputIndex,input,keyPair,void 0,sighashTypes):this._signInput(inputIndex,
keyPair,sighashTypes)}signTaprootInput(inputIndex,keyPair,tapLeafHashToSign,sighashTypes){if(!keyPair||!keyPair.publicKey)throw Error("Need Signer to sign input");const input=(0,utils_1.checkForInput)(this.data.inputs,inputIndex);if((0,bip371_1.isTaprootInput)(input))return this._signTaprootInput(inputIndex,input,keyPair,tapLeafHashToSign,sighashTypes);throw Error(`Input #${inputIndex} is not of type Taproot.`);}_signInput(inputIndex,keyPair,sighashTypes=[transaction_1.Transaction.SIGHASH_ALL]){const {hash,
sighashType}=getHashAndSighashType(this.data.inputs,inputIndex,keyPair.publicKey,this.__CACHE,sighashTypes);keyPair=[{pubkey:keyPair.publicKey,signature:bscript.signature.encode(keyPair.sign(hash),sighashType)}];this.data.updateInput(inputIndex,{partialSig:keyPair});return this}_signTaprootInput(inputIndex,input,keyPair,tapLeafHashToSign,allowedSighashTypes=[transaction_1.Transaction.SIGHASH_DEFAULT]){allowedSighashTypes=this.checkTaprootHashesForSig(inputIndex,input,keyPair,tapLeafHashToSign,allowedSighashTypes);
tapLeafHashToSign=allowedSighashTypes.filter(h=>!h.leafHash).map(h=>(0,bip371_1.serializeTaprootSignature)(keyPair.signSchnorr(h.hash),input.sighashType))[0];allowedSighashTypes=allowedSighashTypes.filter(h=>!!h.leafHash).map(h=>({pubkey:(0,bip371_1.toXOnly)(keyPair.publicKey),signature:(0,bip371_1.serializeTaprootSignature)(keyPair.signSchnorr(h.hash),input.sighashType),leafHash:h.leafHash}));tapLeafHashToSign&&this.data.updateInput(inputIndex,{tapKeySig:tapLeafHashToSign});allowedSighashTypes.length&&
this.data.updateInput(inputIndex,{tapScriptSig:allowedSighashTypes});return this}signInputAsync(inputIndex,keyPair,sighashTypes){return Promise.resolve().then(()=>{if(!keyPair||!keyPair.publicKey)throw Error("Need Signer to sign input");const input=(0,utils_1.checkForInput)(this.data.inputs,inputIndex);return(0,bip371_1.isTaprootInput)(input)?this._signTaprootInputAsync(inputIndex,input,keyPair,void 0,sighashTypes):this._signInputAsync(inputIndex,keyPair,sighashTypes)})}signTaprootInputAsync(inputIndex,
keyPair,tapLeafHash,sighashTypes){return Promise.resolve().then(()=>{if(!keyPair||!keyPair.publicKey)throw Error("Need Signer to sign input");const input=(0,utils_1.checkForInput)(this.data.inputs,inputIndex);if((0,bip371_1.isTaprootInput)(input))return this._signTaprootInputAsync(inputIndex,input,keyPair,tapLeafHash,sighashTypes);throw Error(`Input #${inputIndex} is not of type Taproot.`);})}_signInputAsync(inputIndex,keyPair,sighashTypes=[transaction_1.Transaction.SIGHASH_ALL]){const {hash,sighashType}=
getHashAndSighashType(this.data.inputs,inputIndex,keyPair.publicKey,this.__CACHE,sighashTypes);return Promise.resolve(keyPair.sign(hash)).then(signature=>{signature=[{pubkey:keyPair.publicKey,signature:bscript.signature.encode(signature,sighashType)}];this.data.updateInput(inputIndex,{partialSig:signature})})}async _signTaprootInputAsync(inputIndex,input,keyPair,tapLeafHash,sighashTypes=[transaction_1.Transaction.SIGHASH_DEFAULT]){sighashTypes=this.checkTaprootHashesForSig(inputIndex,input,keyPair,
tapLeafHash,sighashTypes);tapLeafHash=[];var tapKeyHash=sighashTypes.filter(h=>!h.leafHash)[0];tapKeyHash&&(tapKeyHash=Promise.resolve(keyPair.signSchnorr(tapKeyHash.hash)).then(sig=>({tapKeySig:(0,bip371_1.serializeTaprootSignature)(sig,input.sighashType)})),tapLeafHash.push(tapKeyHash));sighashTypes=sighashTypes.filter(h=>!!h.leafHash);sighashTypes.length&&(sighashTypes=sighashTypes.map(tsh=>Promise.resolve(keyPair.signSchnorr(tsh.hash)).then(signature=>({tapScriptSig:[{pubkey:(0,bip371_1.toXOnly)(keyPair.publicKey),
signature:(0,bip371_1.serializeTaprootSignature)(signature,input.sighashType),leafHash:tsh.leafHash}]}))),tapLeafHash.push(...sighashTypes));return Promise.all(tapLeafHash).then(results=>{results.forEach(v=>this.data.updateInput(inputIndex,v))})}checkTaprootHashesForSig(inputIndex,input,keyPair,tapLeafHashToSign,allowedSighashTypes){if("function"!==typeof keyPair.signSchnorr)throw Error(`Need Schnorr Signer to sign taproot input #${inputIndex}.`);input=getTaprootHashesForSig(inputIndex,input,this.data.inputs,
keyPair.publicKey,this.__CACHE,tapLeafHashToSign,allowedSighashTypes);if(!input||!input.length)throw Error(`Can not sign for input #${inputIndex} with the key ${keyPair.publicKey.toString("hex")}`);return input}toBuffer(){checkCache(this.__CACHE);return this.data.toBuffer()}toHex(){checkCache(this.__CACHE);return this.data.toHex()}toBase64(){checkCache(this.__CACHE);return this.data.toBase64()}updateGlobal(updateData){this.data.updateGlobal(updateData);return this}updateInput(inputIndex,updateData){updateData.witnessScript&&
checkInvalidP2WSH(updateData.witnessScript);(0,bip371_1.checkTaprootInputFields)(this.data.inputs[inputIndex],updateData,"updateInput");this.data.updateInput(inputIndex,updateData);updateData.nonWitnessUtxo&&addNonWitnessTxCache(this.__CACHE,this.data.inputs[inputIndex],inputIndex);return this}updateOutput(outputIndex,updateData){(0,bip371_1.checkTaprootOutputFields)(this.data.outputs[outputIndex],updateData,"updateOutput");this.data.updateOutput(outputIndex,updateData);return this}addUnknownKeyValToGlobal(keyVal){this.data.addUnknownKeyValToGlobal(keyVal);
return this}addUnknownKeyValToInput(inputIndex,keyVal){this.data.addUnknownKeyValToInput(inputIndex,keyVal);return this}addUnknownKeyValToOutput(outputIndex,keyVal){this.data.addUnknownKeyValToOutput(outputIndex,keyVal);return this}clearFinalizedInput(inputIndex){this.data.clearFinalizedInput(inputIndex);return this}}exports.Psbt=Psbt;const transactionFromBuffer=buffer=>new PsbtTransaction(buffer);class PsbtTransaction{constructor(buffer=Buffer.from([2,0,0,0,0,0,0,0,0,0])){this.tx=transaction_1.Transaction.fromBuffer(buffer);
checkTxEmpty(this.tx);Object.defineProperty(this,"tx",{enumerable:!1,writable:!0})}getInputOutputCounts(){return{inputCount:this.tx.ins.length,outputCount:this.tx.outs.length}}addInput(input){if(void 0===input.hash||void 0===input.index||!Buffer.isBuffer(input.hash)&&"string"!==typeof input.hash||"number"!==typeof input.index)throw Error("Error adding input.");const hash="string"===typeof input.hash?(0,bufferutils_1.reverseBuffer)(Buffer.from(input.hash,"hex")):input.hash;this.tx.addInput(hash,input.index,
input.sequence)}addOutput(output){if(void 0===output.script||void 0===output.value||!Buffer.isBuffer(output.script)||"number"!==typeof output.value)throw Error("Error adding output.");this.tx.addOutput(output.script,output.value)}toBuffer(){return this.tx.toBuffer()}}const checkRedeemScript=scriptCheckerFactory(payments.p2sh,"Redeem script"),checkWitnessScript=scriptCheckerFactory(payments.p2wsh,"Witness script")}
//# sourceMappingURL=module$node_modules$bitcoinjs_lib$src$psbt.js.map
