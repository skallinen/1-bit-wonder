{
"version":3,
"file":"module$node_modules$bitcoin_address_generator$node_modules$bitcoinjs_lib$src$block.js",
"lineCount":8,
"mappings":"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",
"sources":["node_modules/bitcoin-address-generator/node_modules/bitcoinjs-lib/src/block.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$bitcoin_address_generator$node_modules$bitcoinjs_lib$src$block\"] = function(global,require,module,exports) {\nconst Buffer = require('safe-buffer').Buffer\nconst bcrypto = require('./crypto')\nconst fastMerkleRoot = require('merkle-lib/fastRoot')\nconst typeforce = require('typeforce')\nconst types = require('./types')\nconst varuint = require('varuint-bitcoin')\n\nconst Transaction = require('./transaction')\n\nfunction Block () {\n  this.version = 1\n  this.prevHash = null\n  this.merkleRoot = null\n  this.timestamp = 0\n  this.bits = 0\n  this.nonce = 0\n}\n\nBlock.fromBuffer = function (buffer) {\n  if (buffer.length < 80) throw new Error('Buffer too small (< 80 bytes)')\n\n  let offset = 0\n  function readSlice (n) {\n    offset += n\n    return buffer.slice(offset - n, offset)\n  }\n\n  function readUInt32 () {\n    const i = buffer.readUInt32LE(offset)\n    offset += 4\n    return i\n  }\n\n  function readInt32 () {\n    const i = buffer.readInt32LE(offset)\n    offset += 4\n    return i\n  }\n\n  const block = new Block()\n  block.version = readInt32()\n  block.prevHash = readSlice(32)\n  block.merkleRoot = readSlice(32)\n  block.timestamp = readUInt32()\n  block.bits = readUInt32()\n  block.nonce = readUInt32()\n\n  if (buffer.length === 80) return block\n\n  function readVarInt () {\n    const vi = varuint.decode(buffer, offset)\n    offset += varuint.decode.bytes\n    return vi\n  }\n\n  function readTransaction () {\n    const tx = Transaction.fromBuffer(buffer.slice(offset), true)\n    offset += tx.byteLength()\n    return tx\n  }\n\n  const nTransactions = readVarInt()\n  block.transactions = []\n\n  for (var i = 0; i < nTransactions; ++i) {\n    const tx = readTransaction()\n    block.transactions.push(tx)\n  }\n\n  return block\n}\n\nBlock.prototype.byteLength = function (headersOnly) {\n  if (headersOnly || !this.transactions) return 80\n\n  return 80 + varuint.encodingLength(this.transactions.length) + this.transactions.reduce(function (a, x) {\n    return a + x.byteLength()\n  }, 0)\n}\n\nBlock.fromHex = function (hex) {\n  return Block.fromBuffer(Buffer.from(hex, 'hex'))\n}\n\nBlock.prototype.getHash = function () {\n  return bcrypto.hash256(this.toBuffer(true))\n}\n\nBlock.prototype.getId = function () {\n  return this.getHash().reverse().toString('hex')\n}\n\nBlock.prototype.getUTCDate = function () {\n  const date = new Date(0) // epoch\n  date.setUTCSeconds(this.timestamp)\n\n  return date\n}\n\n// TODO: buffer, offset compatibility\nBlock.prototype.toBuffer = function (headersOnly) {\n  const buffer = Buffer.allocUnsafe(this.byteLength(headersOnly))\n\n  let offset = 0\n  function writeSlice (slice) {\n    slice.copy(buffer, offset)\n    offset += slice.length\n  }\n\n  function writeInt32 (i) {\n    buffer.writeInt32LE(i, offset)\n    offset += 4\n  }\n  function writeUInt32 (i) {\n    buffer.writeUInt32LE(i, offset)\n    offset += 4\n  }\n\n  writeInt32(this.version)\n  writeSlice(this.prevHash)\n  writeSlice(this.merkleRoot)\n  writeUInt32(this.timestamp)\n  writeUInt32(this.bits)\n  writeUInt32(this.nonce)\n\n  if (headersOnly || !this.transactions) return buffer\n\n  varuint.encode(this.transactions.length, buffer, offset)\n  offset += varuint.encode.bytes\n\n  this.transactions.forEach(function (tx) {\n    const txSize = tx.byteLength() // TODO: extract from toBuffer?\n    tx.toBuffer(buffer, offset)\n    offset += txSize\n  })\n\n  return buffer\n}\n\nBlock.prototype.toHex = function (headersOnly) {\n  return this.toBuffer(headersOnly).toString('hex')\n}\n\nBlock.calculateTarget = function (bits) {\n  const exponent = ((bits & 0xff000000) >> 24) - 3\n  const mantissa = bits & 0x007fffff\n  const target = Buffer.alloc(32, 0)\n  target.writeUIntBE(mantissa, 29 - exponent, 3)\n  return target\n}\n\nBlock.calculateMerkleRoot = function (transactions) {\n  typeforce([{ getHash: types.Function }], transactions)\n  if (transactions.length === 0) throw TypeError('Cannot compute merkle root for zero transactions')\n\n  const hashes = transactions.map(function (transaction) {\n    return transaction.getHash()\n  })\n\n  return fastMerkleRoot(hashes, bcrypto.hash256)\n}\n\nBlock.prototype.checkMerkleRoot = function () {\n  if (!this.transactions) return false\n\n  const actualMerkleRoot = Block.calculateMerkleRoot(this.transactions)\n  return this.merkleRoot.compare(actualMerkleRoot) === 0\n}\n\nBlock.prototype.checkProofOfWork = function () {\n  const hash = this.getHash().reverse()\n  const target = Block.calculateTarget(this.bits)\n\n  return hash.compare(target) <= 0\n}\n\nmodule.exports = Block\n\n};"],
"names":["shadow$provide","global","require","module","exports","Block","version","merkleRoot","prevHash","nonce","bits","timestamp","Buffer","bcrypto","fastMerkleRoot","typeforce","types","varuint","Transaction","fromBuffer","Block.fromBuffer","buffer","readSlice","n","offset","slice","readUInt32","i","readUInt32LE","readTransaction","tx","byteLength","length","Error","block","readInt32","readInt32LE","nTransactions","readVarInt","vi","decode","bytes","transactions","push","prototype","Block.prototype.byteLength","headersOnly","encodingLength","reduce","a","x","fromHex","Block.fromHex","hex","from","getHash","Block.prototype.getHash","hash256","toBuffer","getId","Block.prototype.getId","reverse","toString","getUTCDate","Block.prototype.getUTCDate","date","Date","setUTCSeconds","Block.prototype.toBuffer","writeSlice","copy","writeUInt32","writeUInt32LE","allocUnsafe","writeInt32LE","encode","forEach","txSize","toHex","Block.prototype.toHex","calculateTarget","Block.calculateTarget","exponent","mantissa","target","alloc","writeUIntBE","calculateMerkleRoot","Block.calculateMerkleRoot","Function","TypeError","hashes","map","transaction","checkMerkleRoot","Block.prototype.checkMerkleRoot","actualMerkleRoot","compare","checkProofOfWork","Block.prototype.checkProofOfWork","hash"]
}
