shadow$provide.module$node_modules$bitcoin_address_generator$node_modules$bitcoinjs_lib$src$payments$p2wpkh=function(global,require,module,exports){var Buffer=require("module$node_modules$buffer$index").Buffer;const lazy=require("module$node_modules$bitcoin_address_generator$node_modules$bitcoinjs_lib$src$payments$lazy"),typef=require("module$node_modules$typeforce$index"),OPS=require("module$node_modules$bitcoin_ops$index_json"),ecc=require("module$node_modules$tiny_secp256k1$js"),bcrypto=require("module$node_modules$bitcoin_address_generator$node_modules$bitcoinjs_lib$src$crypto"),
bech32=require("module$node_modules$bitcoin_address_generator$node_modules$bech32$index"),bscript=require("module$node_modules$bitcoin_address_generator$node_modules$bitcoinjs_lib$src$script"),BITCOIN_NETWORK=require("module$node_modules$bitcoin_address_generator$node_modules$bitcoinjs_lib$src$networks").bitcoin,EMPTY_BUFFER=Buffer.alloc(0);module.exports=function(a,opts){if(!(a.address||a.hash||a.output||a.pubkey||a.witness))throw new TypeError("Not enough data");opts=Object.assign({validate:!0},
opts||{});typef({address:typef.maybe(typef.String),hash:typef.maybe(typef.BufferN(20)),input:typef.maybe(typef.BufferN(0)),network:typef.maybe(typef.Object),output:typef.maybe(typef.BufferN(22)),pubkey:typef.maybe(ecc.isPoint),signature:typef.maybe(bscript.isCanonicalScriptSignature),witness:typef.maybe(typef.arrayOf(typef.Buffer))},a);const _address=lazy.value(function(){const result=bech32.decode(a.address),version=result.words.shift(),data=bech32.fromWords(result.words);return{version,prefix:result.prefix,
data:Buffer.from(data)}}),network=a.network||BITCOIN_NETWORK,o={network};lazy.prop(o,"address",function(){if(o.hash){var words=bech32.toWords(o.hash);words.unshift(0);return bech32.encode(network.bech32,words)}});lazy.prop(o,"hash",function(){if(a.output)return a.output.slice(2,22);if(a.address)return _address().data;if(a.pubkey||o.pubkey)return bcrypto.hash160(a.pubkey||o.pubkey)});lazy.prop(o,"output",function(){if(o.hash)return bscript.compile([OPS.OP_0,o.hash])});lazy.prop(o,"pubkey",function(){if(a.pubkey)return a.pubkey;
if(a.witness)return a.witness[1]});lazy.prop(o,"signature",function(){if(a.witness)return a.witness[0]});lazy.prop(o,"input",function(){if(o.witness)return EMPTY_BUFFER});lazy.prop(o,"witness",function(){if(a.pubkey&&a.signature)return[a.signature,a.pubkey]});if(opts.validate){let hash;if(a.address){if(network&&network.bech32!==_address().prefix)throw new TypeError("Invalid prefix or Network mismatch");if(0!==_address().version)throw new TypeError("Invalid address version");if(20!==_address().data.length)throw new TypeError("Invalid address data");
hash=_address().data}if(a.hash){if(hash&&!hash.equals(a.hash))throw new TypeError("Hash mismatch");hash=a.hash}if(a.output){if(22!==a.output.length||a.output[0]!==OPS.OP_0||20!==a.output[1])throw new TypeError("Output is invalid");if(hash&&!hash.equals(a.output.slice(2)))throw new TypeError("Hash mismatch");hash=a.output.slice(2)}if(a.pubkey){opts=bcrypto.hash160(a.pubkey);if(hash&&!hash.equals(opts))throw new TypeError("Hash mismatch");hash=opts}if(a.witness){if(2!==a.witness.length)throw new TypeError("Witness is invalid");
if(!bscript.isCanonicalScriptSignature(a.witness[0]))throw new TypeError("Witness has invalid signature");if(!ecc.isPoint(a.witness[1]))throw new TypeError("Witness has invalid pubkey");if(a.signature&&!a.signature.equals(a.witness[0]))throw new TypeError("Signature mismatch");if(a.pubkey&&!a.pubkey.equals(a.witness[1]))throw new TypeError("Pubkey mismatch");opts=bcrypto.hash160(a.witness[1]);if(hash&&!hash.equals(opts))throw new TypeError("Hash mismatch");}}return Object.assign(o,a)}}
//# sourceMappingURL=module$node_modules$bitcoin_address_generator$node_modules$bitcoinjs_lib$src$payments$p2wpkh.js.map
