{
"version":3,
"file":"module$node_modules$bip174$src$lib$parser$fromBuffer.js",
"lineCount":19,
"mappings":"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",
"sources":["node_modules/bip174/src/lib/parser/fromBuffer.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$bip174$src$lib$parser$fromBuffer\"] = function(global,require,module,exports) {\nvar Buffer = require('buffer').Buffer;\n'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst convert = require('../converter');\nconst tools_1 = require('../converter/tools');\nconst varuint = require('../converter/varint');\nconst typeFields_1 = require('../typeFields');\nfunction psbtFromBuffer(buffer, txGetter) {\n  let offset = 0;\n  function varSlice() {\n    const keyLen = varuint.decode(buffer, offset);\n    offset += varuint.encodingLength(keyLen);\n    const key = buffer.slice(offset, offset + keyLen);\n    offset += keyLen;\n    return key;\n  }\n  function readUInt32BE() {\n    const num = buffer.readUInt32BE(offset);\n    offset += 4;\n    return num;\n  }\n  function readUInt8() {\n    const num = buffer.readUInt8(offset);\n    offset += 1;\n    return num;\n  }\n  function getKeyValue() {\n    const key = varSlice();\n    const value = varSlice();\n    return {\n      key,\n      value,\n    };\n  }\n  function checkEndOfKeyValPairs() {\n    if (offset >= buffer.length) {\n      throw new Error('Format Error: Unexpected End of PSBT');\n    }\n    const isEnd = buffer.readUInt8(offset) === 0;\n    if (isEnd) {\n      offset++;\n    }\n    return isEnd;\n  }\n  if (readUInt32BE() !== 0x70736274) {\n    throw new Error('Format Error: Invalid Magic Number');\n  }\n  if (readUInt8() !== 0xff) {\n    throw new Error(\n      'Format Error: Magic Number must be followed by 0xff separator',\n    );\n  }\n  const globalMapKeyVals = [];\n  const globalKeyIndex = {};\n  while (!checkEndOfKeyValPairs()) {\n    const keyVal = getKeyValue();\n    const hexKey = keyVal.key.toString('hex');\n    if (globalKeyIndex[hexKey]) {\n      throw new Error(\n        'Format Error: Keys must be unique for global keymap: key ' + hexKey,\n      );\n    }\n    globalKeyIndex[hexKey] = 1;\n    globalMapKeyVals.push(keyVal);\n  }\n  const unsignedTxMaps = globalMapKeyVals.filter(\n    keyVal => keyVal.key[0] === typeFields_1.GlobalTypes.UNSIGNED_TX,\n  );\n  if (unsignedTxMaps.length !== 1) {\n    throw new Error('Format Error: Only one UNSIGNED_TX allowed');\n  }\n  const unsignedTx = txGetter(unsignedTxMaps[0].value);\n  // Get input and output counts to loop the respective fields\n  const { inputCount, outputCount } = unsignedTx.getInputOutputCounts();\n  const inputKeyVals = [];\n  const outputKeyVals = [];\n  // Get input fields\n  for (const index of tools_1.range(inputCount)) {\n    const inputKeyIndex = {};\n    const input = [];\n    while (!checkEndOfKeyValPairs()) {\n      const keyVal = getKeyValue();\n      const hexKey = keyVal.key.toString('hex');\n      if (inputKeyIndex[hexKey]) {\n        throw new Error(\n          'Format Error: Keys must be unique for each input: ' +\n            'input index ' +\n            index +\n            ' key ' +\n            hexKey,\n        );\n      }\n      inputKeyIndex[hexKey] = 1;\n      input.push(keyVal);\n    }\n    inputKeyVals.push(input);\n  }\n  for (const index of tools_1.range(outputCount)) {\n    const outputKeyIndex = {};\n    const output = [];\n    while (!checkEndOfKeyValPairs()) {\n      const keyVal = getKeyValue();\n      const hexKey = keyVal.key.toString('hex');\n      if (outputKeyIndex[hexKey]) {\n        throw new Error(\n          'Format Error: Keys must be unique for each output: ' +\n            'output index ' +\n            index +\n            ' key ' +\n            hexKey,\n        );\n      }\n      outputKeyIndex[hexKey] = 1;\n      output.push(keyVal);\n    }\n    outputKeyVals.push(output);\n  }\n  return psbtFromKeyVals(unsignedTx, {\n    globalMapKeyVals,\n    inputKeyVals,\n    outputKeyVals,\n  });\n}\nexports.psbtFromBuffer = psbtFromBuffer;\nfunction checkKeyBuffer(type, keyBuf, keyNum) {\n  if (!keyBuf.equals(Buffer.from([keyNum]))) {\n    throw new Error(\n      `Format Error: Invalid ${type} key: ${keyBuf.toString('hex')}`,\n    );\n  }\n}\nexports.checkKeyBuffer = checkKeyBuffer;\nfunction psbtFromKeyVals(\n  unsignedTx,\n  { globalMapKeyVals, inputKeyVals, outputKeyVals },\n) {\n  // That was easy :-)\n  const globalMap = {\n    unsignedTx,\n  };\n  let txCount = 0;\n  for (const keyVal of globalMapKeyVals) {\n    // If a globalMap item needs pubkey, uncomment\n    // const pubkey = convert.globals.checkPubkey(keyVal);\n    switch (keyVal.key[0]) {\n      case typeFields_1.GlobalTypes.UNSIGNED_TX:\n        checkKeyBuffer(\n          'global',\n          keyVal.key,\n          typeFields_1.GlobalTypes.UNSIGNED_TX,\n        );\n        if (txCount > 0) {\n          throw new Error('Format Error: GlobalMap has multiple UNSIGNED_TX');\n        }\n        txCount++;\n        break;\n      case typeFields_1.GlobalTypes.GLOBAL_XPUB:\n        if (globalMap.globalXpub === undefined) {\n          globalMap.globalXpub = [];\n        }\n        globalMap.globalXpub.push(convert.globals.globalXpub.decode(keyVal));\n        break;\n      default:\n        // This will allow inclusion during serialization.\n        if (!globalMap.unknownKeyVals) globalMap.unknownKeyVals = [];\n        globalMap.unknownKeyVals.push(keyVal);\n    }\n  }\n  // Get input and output counts to loop the respective fields\n  const inputCount = inputKeyVals.length;\n  const outputCount = outputKeyVals.length;\n  const inputs = [];\n  const outputs = [];\n  // Get input fields\n  for (const index of tools_1.range(inputCount)) {\n    const input = {};\n    for (const keyVal of inputKeyVals[index]) {\n      convert.inputs.checkPubkey(keyVal);\n      switch (keyVal.key[0]) {\n        case typeFields_1.InputTypes.NON_WITNESS_UTXO:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.NON_WITNESS_UTXO,\n          );\n          if (input.nonWitnessUtxo !== undefined) {\n            throw new Error(\n              'Format Error: Input has multiple NON_WITNESS_UTXO',\n            );\n          }\n          input.nonWitnessUtxo = convert.inputs.nonWitnessUtxo.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.WITNESS_UTXO:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.WITNESS_UTXO,\n          );\n          if (input.witnessUtxo !== undefined) {\n            throw new Error('Format Error: Input has multiple WITNESS_UTXO');\n          }\n          input.witnessUtxo = convert.inputs.witnessUtxo.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.PARTIAL_SIG:\n          if (input.partialSig === undefined) {\n            input.partialSig = [];\n          }\n          input.partialSig.push(convert.inputs.partialSig.decode(keyVal));\n          break;\n        case typeFields_1.InputTypes.SIGHASH_TYPE:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.SIGHASH_TYPE,\n          );\n          if (input.sighashType !== undefined) {\n            throw new Error('Format Error: Input has multiple SIGHASH_TYPE');\n          }\n          input.sighashType = convert.inputs.sighashType.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.REDEEM_SCRIPT:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.REDEEM_SCRIPT,\n          );\n          if (input.redeemScript !== undefined) {\n            throw new Error('Format Error: Input has multiple REDEEM_SCRIPT');\n          }\n          input.redeemScript = convert.inputs.redeemScript.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.WITNESS_SCRIPT:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.WITNESS_SCRIPT,\n          );\n          if (input.witnessScript !== undefined) {\n            throw new Error('Format Error: Input has multiple WITNESS_SCRIPT');\n          }\n          input.witnessScript = convert.inputs.witnessScript.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.BIP32_DERIVATION:\n          if (input.bip32Derivation === undefined) {\n            input.bip32Derivation = [];\n          }\n          input.bip32Derivation.push(\n            convert.inputs.bip32Derivation.decode(keyVal),\n          );\n          break;\n        case typeFields_1.InputTypes.FINAL_SCRIPTSIG:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.FINAL_SCRIPTSIG,\n          );\n          input.finalScriptSig = convert.inputs.finalScriptSig.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.FINAL_SCRIPTWITNESS:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.FINAL_SCRIPTWITNESS,\n          );\n          input.finalScriptWitness = convert.inputs.finalScriptWitness.decode(\n            keyVal,\n          );\n          break;\n        case typeFields_1.InputTypes.POR_COMMITMENT:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.POR_COMMITMENT,\n          );\n          input.porCommitment = convert.inputs.porCommitment.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.TAP_KEY_SIG:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.TAP_KEY_SIG,\n          );\n          input.tapKeySig = convert.inputs.tapKeySig.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.TAP_SCRIPT_SIG:\n          if (input.tapScriptSig === undefined) {\n            input.tapScriptSig = [];\n          }\n          input.tapScriptSig.push(convert.inputs.tapScriptSig.decode(keyVal));\n          break;\n        case typeFields_1.InputTypes.TAP_LEAF_SCRIPT:\n          if (input.tapLeafScript === undefined) {\n            input.tapLeafScript = [];\n          }\n          input.tapLeafScript.push(convert.inputs.tapLeafScript.decode(keyVal));\n          break;\n        case typeFields_1.InputTypes.TAP_BIP32_DERIVATION:\n          if (input.tapBip32Derivation === undefined) {\n            input.tapBip32Derivation = [];\n          }\n          input.tapBip32Derivation.push(\n            convert.inputs.tapBip32Derivation.decode(keyVal),\n          );\n          break;\n        case typeFields_1.InputTypes.TAP_INTERNAL_KEY:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.TAP_INTERNAL_KEY,\n          );\n          input.tapInternalKey = convert.inputs.tapInternalKey.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.TAP_MERKLE_ROOT:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.TAP_MERKLE_ROOT,\n          );\n          input.tapMerkleRoot = convert.inputs.tapMerkleRoot.decode(keyVal);\n          break;\n        default:\n          // This will allow inclusion during serialization.\n          if (!input.unknownKeyVals) input.unknownKeyVals = [];\n          input.unknownKeyVals.push(keyVal);\n      }\n    }\n    inputs.push(input);\n  }\n  for (const index of tools_1.range(outputCount)) {\n    const output = {};\n    for (const keyVal of outputKeyVals[index]) {\n      convert.outputs.checkPubkey(keyVal);\n      switch (keyVal.key[0]) {\n        case typeFields_1.OutputTypes.REDEEM_SCRIPT:\n          checkKeyBuffer(\n            'output',\n            keyVal.key,\n            typeFields_1.OutputTypes.REDEEM_SCRIPT,\n          );\n          if (output.redeemScript !== undefined) {\n            throw new Error('Format Error: Output has multiple REDEEM_SCRIPT');\n          }\n          output.redeemScript = convert.outputs.redeemScript.decode(keyVal);\n          break;\n        case typeFields_1.OutputTypes.WITNESS_SCRIPT:\n          checkKeyBuffer(\n            'output',\n            keyVal.key,\n            typeFields_1.OutputTypes.WITNESS_SCRIPT,\n          );\n          if (output.witnessScript !== undefined) {\n            throw new Error('Format Error: Output has multiple WITNESS_SCRIPT');\n          }\n          output.witnessScript = convert.outputs.witnessScript.decode(keyVal);\n          break;\n        case typeFields_1.OutputTypes.BIP32_DERIVATION:\n          if (output.bip32Derivation === undefined) {\n            output.bip32Derivation = [];\n          }\n          output.bip32Derivation.push(\n            convert.outputs.bip32Derivation.decode(keyVal),\n          );\n          break;\n        case typeFields_1.OutputTypes.TAP_INTERNAL_KEY:\n          checkKeyBuffer(\n            'output',\n            keyVal.key,\n            typeFields_1.OutputTypes.TAP_INTERNAL_KEY,\n          );\n          output.tapInternalKey = convert.outputs.tapInternalKey.decode(keyVal);\n          break;\n        case typeFields_1.OutputTypes.TAP_TREE:\n          checkKeyBuffer(\n            'output',\n            keyVal.key,\n            typeFields_1.OutputTypes.TAP_TREE,\n          );\n          output.tapTree = convert.outputs.tapTree.decode(keyVal);\n          break;\n        case typeFields_1.OutputTypes.TAP_BIP32_DERIVATION:\n          if (output.tapBip32Derivation === undefined) {\n            output.tapBip32Derivation = [];\n          }\n          output.tapBip32Derivation.push(\n            convert.outputs.tapBip32Derivation.decode(keyVal),\n          );\n          break;\n        default:\n          if (!output.unknownKeyVals) output.unknownKeyVals = [];\n          output.unknownKeyVals.push(keyVal);\n      }\n    }\n    outputs.push(output);\n  }\n  return { globalMap, inputs, outputs };\n}\nexports.psbtFromKeyVals = psbtFromKeyVals;\n\n};"],
"names":["shadow$provide","global","require","module","exports","checkKeyBuffer","type","keyBuf","keyNum","equals","Buffer","from","Error","toString","psbtFromKeyVals","unsignedTx","globalMapKeyVals","inputKeyVals","outputKeyVals","globalMap","txCount","keyVal","key","typeFields_1","GlobalTypes","UNSIGNED_TX","GLOBAL_XPUB","undefined","globalXpub","push","convert","globals","decode","unknownKeyVals","inputCount","length","outputCount","inputs","outputs","index","tools_1","range","input","checkPubkey","InputTypes","NON_WITNESS_UTXO","nonWitnessUtxo","WITNESS_UTXO","witnessUtxo","PARTIAL_SIG","partialSig","SIGHASH_TYPE","sighashType","REDEEM_SCRIPT","redeemScript","WITNESS_SCRIPT","witnessScript","BIP32_DERIVATION","bip32Derivation","FINAL_SCRIPTSIG","finalScriptSig","FINAL_SCRIPTWITNESS","finalScriptWitness","POR_COMMITMENT","porCommitment","TAP_KEY_SIG","tapKeySig","TAP_SCRIPT_SIG","tapScriptSig","TAP_LEAF_SCRIPT","tapLeafScript","TAP_BIP32_DERIVATION","tapBip32Derivation","TAP_INTERNAL_KEY","tapInternalKey","TAP_MERKLE_ROOT","tapMerkleRoot","output","OutputTypes","TAP_TREE","tapTree","Object","defineProperty","value","varuint","psbtFromBuffer","buffer","txGetter","varSlice","keyLen","offset","encodingLength","slice","getKeyValue","checkEndOfKeyValPairs","isEnd","readUInt8","readUInt32BE","num","globalKeyIndex","hexKey","unsignedTxMaps","filter","getInputOutputCounts","inputKeyIndex","outputKeyIndex"]
}
