shadow$provide.module$node_modules$bitcoin_address_generator$index=function(global,require,module,exports){var Buffer=require("module$node_modules$buffer$index").Buffer;const bitcoin=require("module$node_modules$bitcoin_address_generator$node_modules$bitcoinjs_lib$src$index"),ec=require("module$node_modules$elliptic$lib$elliptic").ec,sha256=require("module$node_modules$js_sha256$src$sha256"),ripemd160=require("module$node_modules$ripemd160$index"),base58=require("module$node_modules$bs58$index");
let Bitcoin={createWalletAddress:callback=>{let privateKey=Bitcoin.createPrivateKey();var hash=Bitcoin.generatePublicKeyHash(privateKey);hash=Bitcoin.createPublicAddress(hash);callback({key:privateKey,address:hash})},createPrivateKey:()=>bitcoin.ECPair.makeRandom().publicKey.toString("hex"),generatePublicKeyHash:privateKey=>{privateKey=(new ec("secp256k1")).keyFromPrivate(privateKey).getPublic("hex");privateKey=sha256(Buffer.from(privateKey,"hex"));return(new ripemd160).update(Buffer.from(privateKey,
"hex")).digest()},createPublicAddress:publicKeyHash=>{publicKeyHash=Buffer.from("00"+publicKeyHash.toString("hex"),"hex");var step2=sha256(publicKeyHash);step2=sha256(Buffer.from(step2,"hex")).substring(0,8);publicKeyHash=publicKeyHash.toString("hex")+step2;return base58.encode(Buffer.from(publicKeyHash,"hex"))}};module.exports=Bitcoin}
//# sourceMappingURL=module$node_modules$bitcoin_address_generator$index.js.map
