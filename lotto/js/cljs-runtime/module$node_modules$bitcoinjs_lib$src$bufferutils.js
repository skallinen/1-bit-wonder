shadow$provide.module$node_modules$bitcoinjs_lib$src$bufferutils=function(global,require,module,exports){function verifuint(value,max){if("number"!==typeof value)throw Error("cannot write a non-number as a number");if(0>value)throw Error("specified a negative value for writing an unsigned value");if(value>max)throw Error("RangeError: value out of range");if(Math.floor(value)!==value)throw Error("value has a fractional component");}function readUInt64LE(buffer,offset){const a=buffer.readUInt32LE(offset);
buffer=buffer.readUInt32LE(offset+4);buffer*=4294967296;verifuint(buffer+a,9007199254740991);return buffer+a}function writeUInt64LE(buffer,value,offset){verifuint(value,9007199254740991);buffer.writeInt32LE(value&-1,offset);buffer.writeUInt32LE(Math.floor(value/4294967296),offset+4);return offset+8}var Buffer=require("module$node_modules$buffer$index").Buffer;"use strict";Object.defineProperty(exports,"__esModule",{value:!0});exports.BufferReader=exports.BufferWriter=exports.cloneBuffer=exports.reverseBuffer=
exports.writeUInt64LE=exports.readUInt64LE=exports.varuint=void 0;const types=require("module$node_modules$bitcoinjs_lib$src$types"),{typeforce}=types,varuint=require("module$node_modules$varuint_bitcoin$index");exports.varuint=varuint;exports.readUInt64LE=readUInt64LE;exports.writeUInt64LE=writeUInt64LE;exports.reverseBuffer=function(buffer){if(1>buffer.length)return buffer;let j=buffer.length-1,tmp;for(let i=0;i<buffer.length/2;i++)tmp=buffer[i],buffer[i]=buffer[j],buffer[j]=tmp,j--;return buffer};
exports.cloneBuffer=function(buffer){const clone=Buffer.allocUnsafe(buffer.length);buffer.copy(clone);return clone};class BufferWriter{static withCapacity(size){return new BufferWriter(Buffer.alloc(size))}constructor(buffer,offset=0){this.buffer=buffer;this.offset=offset;typeforce(types.tuple(types.Buffer,types.UInt32),[buffer,offset])}writeUInt8(i){this.offset=this.buffer.writeUInt8(i,this.offset)}writeInt32(i){this.offset=this.buffer.writeInt32LE(i,this.offset)}writeUInt32(i){this.offset=this.buffer.writeUInt32LE(i,
this.offset)}writeUInt64(i){this.offset=writeUInt64LE(this.buffer,i,this.offset)}writeVarInt(i){varuint.encode(i,this.buffer,this.offset);this.offset+=varuint.encode.bytes}writeSlice(slice){if(this.buffer.length<this.offset+slice.length)throw Error("Cannot write slice out of bounds");this.offset+=slice.copy(this.buffer,this.offset)}writeVarSlice(slice){this.writeVarInt(slice.length);this.writeSlice(slice)}writeVector(vector){this.writeVarInt(vector.length);vector.forEach(buf=>this.writeVarSlice(buf))}end(){if(this.buffer.length===
this.offset)return this.buffer;throw Error(`buffer size ${this.buffer.length}, offset ${this.offset}`);}}exports.BufferWriter=BufferWriter;class BufferReader{constructor(buffer,offset=0){this.buffer=buffer;this.offset=offset;typeforce(types.tuple(types.Buffer,types.UInt32),[buffer,offset])}readUInt8(){const result=this.buffer.readUInt8(this.offset);this.offset++;return result}readInt32(){const result=this.buffer.readInt32LE(this.offset);this.offset+=4;return result}readUInt32(){const result=this.buffer.readUInt32LE(this.offset);
this.offset+=4;return result}readUInt64(){const result=readUInt64LE(this.buffer,this.offset);this.offset+=8;return result}readVarInt(){const vi=varuint.decode(this.buffer,this.offset);this.offset+=varuint.decode.bytes;return vi}readSlice(n){if(this.buffer.length<this.offset+n)throw Error("Cannot read slice out of bounds");const result=this.buffer.slice(this.offset,this.offset+n);this.offset+=n;return result}readVarSlice(){return this.readSlice(this.readVarInt())}readVector(){const count=this.readVarInt(),
vector=[];for(let i=0;i<count;i++)vector.push(this.readVarSlice());return vector}}exports.BufferReader=BufferReader}
//# sourceMappingURL=module$node_modules$bitcoinjs_lib$src$bufferutils.js.map
