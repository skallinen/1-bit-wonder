{
"version":3,
"file":"module$node_modules$tiny_secp256k1$rfc6979.js",
"lineCount":2,
"mappings":"AAAAA,cAAA,CAAA,0CAAA,CAA+D,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CACvG,IAAIC,OAASH,OAAA,CAAQ,kCAAR,CAAkBG,CAAAA,MAC/B,OAAMC,WAAaJ,OAAA,CAAQ,yCAAR,CAAnB,CAEMK,KAAOF,MAAOG,CAAAA,KAAP,CAAa,CAAb,CAAgB,CAAhB,CAFb,CAGMC,MAAQJ,MAAOG,CAAAA,KAAP,CAAa,CAAb,CAAgB,CAAhB,CA0DdL,OAAOC,CAAAA,OAAP,CAvDAM,QAAgC,CAACC,IAAD,CAAOC,CAAP,CAAUC,QAAV,CAAoBC,SAApB,CAA+BC,YAA/B,CAA6C,CAI3E,IAAIC,EAAIX,MAAOG,CAAAA,KAAP,CAAa,EAAb,CAAiB,CAAjB,CAAR,CACIS,EAAIZ,MAAOG,CAAAA,KAAP,CAAa,EAAb,CAAiB,CAAjB,CAGRQ,EAAA,CAAIV,UAAA,CAAW,QAAX,CAAqBU,CAArB,CACDE,CAAAA,MADC,CACMD,CADN,CAEDC,CAAAA,MAFC,CAEMT,KAFN,CAGDS,CAAAA,MAHC,CAGMN,CAHN,CAIDM,CAAAA,MAJC,CAIMP,IAJN,CAKDO,CAAAA,MALC,CAKMH,YALN,EAKsB,EALtB,CAMDI,CAAAA,MANC,EASJF,EAAA,CAAIX,UAAA,CAAW,QAAX;AAAqBU,CAArB,CAAwBE,CAAAA,MAAxB,CAA+BD,CAA/B,CAAkCE,CAAAA,MAAlC,EAGJH,EAAA,CAAIV,UAAA,CAAW,QAAX,CAAqBU,CAArB,CACDE,CAAAA,MADC,CACMD,CADN,CAEDC,CAAAA,MAFC,CAEMX,IAFN,CAGDW,CAAAA,MAHC,CAGMN,CAHN,CAIDM,CAAAA,MAJC,CAIMP,IAJN,CAKDO,CAAAA,MALC,CAKMH,YALN,EAKsB,EALtB,CAMDI,CAAAA,MANC,EASJF,EAAA,CAAIX,UAAA,CAAW,QAAX,CAAqBU,CAArB,CAAwBE,CAAAA,MAAxB,CAA+BD,CAA/B,CAAkCE,CAAAA,MAAlC,EASJ,KAHIC,IAGJ,CALAH,CAKA,CALIX,UAAA,CAAW,QAAX,CAAqBU,CAArB,CAAwBE,CAAAA,MAAxB,CAA+BD,CAA/B,CAAkCE,CAAAA,MAAlC,EAKJ,CAAO,CAACL,SAAA,CAAUM,IAAV,CAAR,EAAwB,CAACP,QAAA,CAASO,IAAT,CAAzB,CAAA,CACEJ,CAUA,CAVIV,UAAA,CAAW,QAAX,CAAqBU,CAArB,CACDE,CAAAA,MADC,CACMD,CADN,CAEDC,CAAAA,MAFC,CAEMT,KAFN,CAGDU,CAAAA,MAHC,EAUJ,CALAF,CAKA,CALIX,UAAA,CAAW,QAAX,CAAqBU,CAArB,CAAwBE,CAAAA,MAAxB,CAA+BD,CAA/B,CAAkCE,CAAAA,MAAlC,EAKJ,CAAAC,IAAA,CADAH,CACA,CADIX,UAAA,CAAW,QAAX,CAAqBU,CAArB,CAAwBE,CAAAA,MAAxB,CAA+BD,CAA/B,CAAkCE,CAAAA,MAAlC,EAIN,OAAOC,KApDoE,CAR0B;",
"sources":["node_modules/tiny-secp256k1/rfc6979.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$tiny_secp256k1$rfc6979\"] = function(global,require,module,exports) {\nvar Buffer = require('buffer').Buffer;\nconst createHmac = require('create-hmac')\n\nconst ONE1 = Buffer.alloc(1, 1)\nconst ZERO1 = Buffer.alloc(1, 0)\n\n// https://tools.ietf.org/html/rfc6979#section-3.2\nfunction deterministicGenerateK (hash, x, checkSig, isPrivate, extraEntropy) {\n  // Step A, ignored as hash already provided\n  // Step B\n  // Step C\n  let k = Buffer.alloc(32, 0)\n  let v = Buffer.alloc(32, 1)\n\n  // Step D\n  k = createHmac('sha256', k)\n    .update(v)\n    .update(ZERO1)\n    .update(x)\n    .update(hash)\n    .update(extraEntropy || '')\n    .digest()\n\n  // Step E\n  v = createHmac('sha256', k).update(v).digest()\n\n  // Step F\n  k = createHmac('sha256', k)\n    .update(v)\n    .update(ONE1)\n    .update(x)\n    .update(hash)\n    .update(extraEntropy || '')\n    .digest()\n\n  // Step G\n  v = createHmac('sha256', k).update(v).digest()\n\n  // Step H1/H2a, ignored as tlen === qlen (256 bit)\n  // Step H2b\n  v = createHmac('sha256', k).update(v).digest()\n\n  let T = v\n\n  // Step H3, repeat until T is within the interval [1, n - 1] and is suitable for ECDSA\n  while (!isPrivate(T) || !checkSig(T)) {\n    k = createHmac('sha256', k)\n      .update(v)\n      .update(ZERO1)\n      .digest()\n\n    v = createHmac('sha256', k).update(v).digest()\n\n    // Step H1/H2a, again, ignored as tlen === qlen (256 bit)\n    // Step H2b again\n    v = createHmac('sha256', k).update(v).digest()\n    T = v\n  }\n\n  return T\n}\n\nmodule.exports = deterministicGenerateK\n\n};"],
"names":["shadow$provide","global","require","module","exports","Buffer","createHmac","ONE1","alloc","ZERO1","deterministicGenerateK","hash","x","checkSig","isPrivate","extraEntropy","k","v","update","digest","T"]
}
