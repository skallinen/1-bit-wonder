shadow$provide.module$node_modules$bitcoinjs_lib$src$payments$p2wsh=function(global,require,module,exports){function stacksEqual(a,b){return a.length!==b.length?!1:a.every((x,i)=>x.equals(b[i]))}function chunkHasUncompressedPubkey(chunk){return Buffer.isBuffer(chunk)&&65===chunk.length&&4===chunk[0]&&(0,types_1.isPoint)(chunk)?!0:!1}var Buffer=require("module$node_modules$buffer$index").Buffer;"use strict";Object.defineProperty(exports,"__esModule",{value:!0});exports.p2wsh=void 0;const bcrypto=require("module$node_modules$bitcoinjs_lib$src$crypto"),
networks_1=require("module$node_modules$bitcoinjs_lib$src$networks"),bscript=require("module$node_modules$bitcoinjs_lib$src$script"),types_1=require("module$node_modules$bitcoinjs_lib$src$types"),lazy=require("module$node_modules$bitcoinjs_lib$src$payments$lazy"),bech32_1=require("module$node_modules$bech32$dist$index"),OPS=bscript.OPS,EMPTY_BUFFER=Buffer.alloc(0);exports.p2wsh=function(a,opts){if(!(a.address||a.hash||a.output||a.redeem||a.witness))throw new TypeError("Not enough data");opts=Object.assign({validate:!0},
opts||{});(0,types_1.typeforce)({network:types_1.typeforce.maybe(types_1.typeforce.Object),address:types_1.typeforce.maybe(types_1.typeforce.String),hash:types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),output:types_1.typeforce.maybe(types_1.typeforce.BufferN(34)),redeem:types_1.typeforce.maybe({input:types_1.typeforce.maybe(types_1.typeforce.Buffer),network:types_1.typeforce.maybe(types_1.typeforce.Object),output:types_1.typeforce.maybe(types_1.typeforce.Buffer),witness:types_1.typeforce.maybe(types_1.typeforce.arrayOf(types_1.typeforce.Buffer))}),
input:types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),witness:types_1.typeforce.maybe(types_1.typeforce.arrayOf(types_1.typeforce.Buffer))},a);const _address=lazy.value(()=>{const result=bech32_1.bech32.decode(a.address),version=result.words.shift(),data=bech32_1.bech32.fromWords(result.words);return{version,prefix:result.prefix,data:Buffer.from(data)}}),_rchunks=lazy.value(()=>bscript.decompile(a.redeem.input));let network=a.network;network||(network=a.redeem&&a.redeem.network||networks_1.bitcoin);
const o={network};lazy.prop(o,"address",()=>{if(o.hash){var words=bech32_1.bech32.toWords(o.hash);words.unshift(0);return bech32_1.bech32.encode(network.bech32,words)}});lazy.prop(o,"hash",()=>{if(a.output)return a.output.slice(2);if(a.address)return _address().data;if(o.redeem&&o.redeem.output)return bcrypto.sha256(o.redeem.output)});lazy.prop(o,"output",()=>{if(o.hash)return bscript.compile([OPS.OP_0,o.hash])});lazy.prop(o,"redeem",()=>{if(a.witness)return{output:a.witness[a.witness.length-1],input:EMPTY_BUFFER,
witness:a.witness.slice(0,-1)}});lazy.prop(o,"input",()=>{if(o.witness)return EMPTY_BUFFER});lazy.prop(o,"witness",()=>{if(a.redeem&&a.redeem.input&&0<a.redeem.input.length&&a.redeem.output&&0<a.redeem.output.length){const stack=bscript.toStack(_rchunks());o.redeem=Object.assign({witness:stack},a.redeem);o.redeem.input=EMPTY_BUFFER;return[].concat(stack,a.redeem.output)}if(a.redeem&&a.redeem.output&&a.redeem.witness)return[].concat(a.redeem.witness,a.redeem.output)});lazy.prop(o,"name",()=>{const nameParts=
["p2wsh"];void 0!==o.redeem&&void 0!==o.redeem.name&&nameParts.push(o.redeem.name);return nameParts.join("-")});if(opts.validate){opts=Buffer.from([]);if(a.address){if(_address().prefix!==network.bech32)throw new TypeError("Invalid prefix or Network mismatch");if(0!==_address().version)throw new TypeError("Invalid address version");if(32!==_address().data.length)throw new TypeError("Invalid address data");opts=_address().data}if(a.hash){if(0<opts.length&&!opts.equals(a.hash))throw new TypeError("Hash mismatch");
opts=a.hash}if(a.output){if(34!==a.output.length||a.output[0]!==OPS.OP_0||32!==a.output[1])throw new TypeError("Output is invalid");var hash2=a.output.slice(2);if(0<opts.length&&!opts.equals(hash2))throw new TypeError("Hash mismatch");opts=hash2}if(a.redeem){if(a.redeem.network&&a.redeem.network!==network)throw new TypeError("Network mismatch");if(a.redeem.input&&0<a.redeem.input.length&&a.redeem.witness&&0<a.redeem.witness.length)throw new TypeError("Ambiguous witness source");if(a.redeem.output){if(0===
bscript.decompile(a.redeem.output).length)throw new TypeError("Redeem.output is invalid");hash2=bcrypto.sha256(a.redeem.output);if(0<opts.length&&!opts.equals(hash2))throw new TypeError("Hash mismatch");opts=hash2}if(a.redeem.input&&!bscript.isPushOnly(_rchunks()))throw new TypeError("Non push-only scriptSig");if(a.witness&&a.redeem.witness&&!stacksEqual(a.witness,a.redeem.witness))throw new TypeError("Witness and redeem.witness mismatch");if(a.redeem.input&&_rchunks().some(chunkHasUncompressedPubkey)||
a.redeem.output&&(bscript.decompile(a.redeem.output)||[]).some(chunkHasUncompressedPubkey))throw new TypeError("redeem.input or redeem.output contains uncompressed pubkey");}if(a.witness&&0<a.witness.length){opts=a.witness[a.witness.length-1];if(a.redeem&&a.redeem.output&&!a.redeem.output.equals(opts))throw new TypeError("Witness and redeem.output mismatch");if(a.witness.some(chunkHasUncompressedPubkey)||(bscript.decompile(opts)||[]).some(chunkHasUncompressedPubkey))throw new TypeError("Witness contains uncompressed pubkey");
}}return Object.assign(o,a)}}
//# sourceMappingURL=module$node_modules$bitcoinjs_lib$src$payments$p2wsh.js.map
